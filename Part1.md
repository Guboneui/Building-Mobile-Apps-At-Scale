### PART1: Challenges due to the nature of mobile applications

앱 개발 경험이 없는 사람들은 네이티브 앱 개발이 웹 개발과 비슷할 것이라 생각하지만 그렇지 않다.

웹 혹은 백엔드와 다르게, 앱의 이진 배포(binary distribution of mobile apps), 낮은 전력 소모(low connectivity setup), 앱 푸시, 딥 링크, 인앱 결제 등 기능을 통합해야 한다.

---

#### 1. State Management

네이티브 개발에 있어 상태관리는 복잡하다. 모던 웹, 백엔드도 비슷하지만, 네이티브 개발에서는 앱의 `app lifeCycle events`, `화면 전환`을 신경써야 한다. 라이프 사이클과 관련한 예시로, 
앱이 일시정지 또는 백그라운드로 이동한 후, 포그라운드로 돌아오거나 중단되는 경우가 있다. (the app pausing and going to the background, the returning to the foreground or being suspened)

`이벤트`는 대부분의 앱에서 상태 변화를 일으키며, '상태 변경', '네트워크 요청', '유저 인풋' 같은 비동기 방식으로 트리거 된다. 대부분의 버그 또는 앱 크래쉬는 `이벤트`와 `앱 상태 붕괴`로 발생하며, 상태가 붕괴되는 문제는
전역(global) 또는 지역(local) 상태가 서로 알려지지 않은 여러 구성 요소에 의해 조작되는 앱의 일반적인 문제이다. 이러한 문제를 겪는 팀은 컴포넌트와 앱의 상태를 분리하고(isolate component and application state),
반응형 상태 관리(reactive state management)를 도입해야 한다.

`반응형 프로그래밍(Reactive Programming)`은 크고, 상태를 관리하기 위한 앱에서, 상태 변경을 격리시키기 위해 선호되는 프로그래밍 방식이다. 상태를 가능한한 변하지 않도록 유지하고, 모델을 상태 변화를 방출하는 불변의 객체로 저장한다.
`컴포넌트 트리 아래(down a tree of components)`방향으로 상태를 변경해 나가는 과정이 지루할 수 있지만, 지루함은 컴포넌트에서 의도하지 않은 상태 변경을 만들기 어렵게 한다.

같은 자원을 공유하는 앱과 짧은 시간에 OS Killing 앱은 모바일 개발을 위한 것과 백엔드 또는 웹 개발을 위한 개발에 두 가지 큰 차이가 있다. OS는 'CPU', '메모리', '에너지 소비'를 모니터링 한다. 만약 특정 앱이 많은 리소스를 활용하고 있다고 OS가 판단한다면, 약간의 경고(little warning)로 종료될 수 있다. **이것은 앱의 상태 변경에 대응하고, 상태를 저정하고, 앱을 실행 중인 곳으로 복원 하는 앱 개발자의 책임이다.** iOS 에서 이것을 상태를 관리하고, 그 사이의 전환을 처리하는 것을 의미한다(On iOS, this means handling app states and transitions between them)

권한, 블루투스와 같은 전역적인 앱 상태는 도전 과제를 제시한다. 하나의 전역 상태가 바뀔 때마다 네트워크 연결이 끊어지면 앱의 다른 부분은 다르게 반응해야할 수도 있다.
전역 상태와 함께 특정 컴포넌트가 상태 변화를 듣도록 결정되어야 한다. 하나의 스팩트럼의 앱의 화면 또는 컴포넌트는 전역 상택의 변화를 들을 수 있다. 이로 인해 많은 코드 중복이 발생하지만, 컴포넌트는 전역 상태를 핸들링 한다(components handling all of the global state concerns).
결과적으로 컴포넌트는 특정 글로벌 상태 변화를 듣고 이를 앱의 특정 부분으로 전달할 수 있다. 이것은 덜 복잡한 코드의 결과가 되지만, 전역 상태 관리와 그것을 알고 있는 컴포넌트 사이 심한 결합(tight coupling)을 가지고 있다. 

딥링크, 또는 내부 네비게이션(internal shortcut navitaion points) 또한 앱 상태 관리에 복잡성을 더한다. 딥링크를 예로 들면, 딥링크가 활성화 된 후 앱의 상태를 설정해야 할 수도 있다. 

---

#### 2. Mistakes Are Hard To Revert

모바일 앱은 바이너리 파일로 구성되어 배포된다. 클라이언트 파트 버그가 있는 버전으로 유저가 업데이트를 진행하면, 유저는 새로운 버전이 업데이트되기까지 해당 버전에 갇히게 된다. 

애플과 구글 모두 앱으로 실행 가능한 코드를 전송하는 것에 엄격한 제한을 두고 있다. 애플은 앱스토어 가이드 라인에서 기능을 변경하는 코드를 실행시키는 것을 금지하며, 구글은 프로그램 정책에 따라 관련 없는 실행 가능한 코드를 악성 코드로 간주한다.
그러나, 잘못된 버그를 되돌리는 기능은 양쪽 스토어의 정책에 포함되어야 한다. 또한 애플을 자바스크립트같은 네이티브 코드가 아닌 코드도 허용하고 있으며, `코드 푸시(CodePush)` 와 같은 솔루션이 인기있는 이유다.
코드 푸시는 `React Native`, `Cordova` 앱이 즉시 업데이트 될 수 있도록 허용한다. 우버에서 우리는 자체 솔루션을 구축했다. 

- 새로운 앱을 배포하는데까지는 며칠이 걸린다. 애플의 경우 모든 앱에 대해 수동 검토가 이뤄지며, 이는 24~48 시간 정도가 걸리며, 모든 앱은 리젝 당할 수 있다. 2020.06을 기준으로 애플은 가이드라인 위반으로 법적 문제를 제외하고, 버그 수정이 더 이상 지연되지 않는 방침을 변경했다. 
- 사용자들은 스토어에 새로운 버전이 배포된 이후, 실제 신규 버전을 배포 받기 까지 며칠이 걸리며, 이는 자동 업데이트가 켜져 있는 사용자도 마찬가지다. 
- 모든 사용자가 이 업데이트된 버전을 받을 것이라고 가정할 수 없다. 몇몇 유저는 자동 업데이트를 비활성화 했을 수도 있으며, 업데이트를 하더라도 몇몇개의 버전을 건너뛸 수 있다. 

```
it was the most terrifying thing to take 10,000 diffs, package it into effectively a bullet,
fire that bullet at the horizon and that bullet once it leaves the barrel, it's gone.
i cannot get it back, and it flies flat and true with no friction and to gravity till the heat death of the universe.
it's gone. i can't fix it
```

이는 앱의 모든 이전 버전이 무기한으로 지원되어야 함을 의미하며, 지원하도록 만들어야 한다. 유일한 예외는 자체 제작 컨토롤을 도입하고, 과거 버전을 지원하기 위해 강제 업데이트 메커니즘을 구축하는 경우다. 
안드로이드의 경우 `Play Core`라이브러리에서 앱 내 업데이트를 지원하지만, iOS는 비슷한 내장 지원 기능을 가지고 있지 않다.

수백만명의 사용자가 있는 앱이 있다고 가정하면, 이전 버전에서 발생하는 버그나 회귀를 최소화하기 위해 어떤 조치를 취할 수 있을까?

- 모든 레벨의 테스트를 진행하라(Do Thorough testing at all levels). 자동 테스트 매뉴얼 테스트, 그리고 쉬운 피드백을 받을 수 있는 베타 테스트까지. 많은 회사의 일반적인 접근 방식은 일주일 동안 사용해 볼 수 있도록
  베타 앱을 출시하고 모든 문제에 대한 피드백을 수집하는 것이다.
- 기능 플래그 시스템을 갖추고 있으므로, 버그를 되돌릴 수 있다. 여전히 기능 플래그는 더 많은 문제점을 더한다.
- 예상대로 작동하도록 모니터링과 함께 점진적인 규칙울 고려해라.
- 강제 업데이트는 강력한 솔루션이지만, 이를 실행하기 위해서는 고려해야 하며, 이 과정에서 몇몇 고객들이 떠날 수도 있다.

---

#### 3. The Long Tail Of Old App Versions

오래된 앱 버전은 최대 몇 년 동안 유지되며, 엄격한 강제 업데이트 정책을 시행하는 몇몇 팀인 경우에만 짧게 유지될 것이다. 

대부분의 사용자는 며칠 안에 새로운 앱 버전으로 업데이트 하지만, 여러 버전이 뒤쳐진 사용자가 있을 것이다. 일부 사용자는 의도적으로 자동 업데이트를 비활성화 하지만, 오래된 기기 또는 OS로 인해 사용이 불가능해진다.
또한 오래된 앱 버전은 보수가 적은 많은 노력이기 때문에 정기적으로 테스트 되지 않는다. 

깨지지 않는 백엔드(서버)의 변경 조차도 특정 응답의 내용을 변경하는 것 처럼 오래된 버전을 깨뜨릴 수 있다. 이러한 크래쉬를 피하기 위한 몇 가지 방법이 있다. 

- 전용 도구를 사용해 네트워크 응답 처리 및 파싱을 견고하게 구축해야한다. `GraphQL`과 같이 클라이언트와 백엔드 간에 생성된 더 강력하고 형식화된 것을 선호한다. 이는 수동으로 유효성을 검사해야하는 `REST` 인터페이스보다 훨씬 더 나은 방법으로, 누군가 모바일에서 파싱 로직을 업데이트를 잊어버린 경우 `REST` 인터페이스에서 예기지 않은 오류가 발생할 수 있다.
- 백엔드 변경을 깨기 위해 미리 계획해야 한다. 백엔드 팀과 열린 커뮤티케이션을 가져라. 오래된 앱을 테스트 할 수 있는 방법이 있다. 강제 업그레이드가 모든 현재 앱 사용자를 이전 엔드포인트에서 옮길 때까지 새로운 엔드포인트를 구축하고 오래된 엔트포인트를 폐기하지 않는 것을 고려해야 한다.
- 벡엔드 엔드포인트의 버전을 관리할 때, 호환성에 영향을 미치는 변경사항이 있을 경우 기존 엔드포인트를 폐기하고 새로운 버전의 엔드포인트를 만드는 것이 일반적이다. 
- 백엔드 엔드포인트를 폐기하는 경우, 트래픽을 모니터링하고 필요한 경우 요청을 효율적으로 전달할 수 있는 마이그레이션 계획이 필요하다. 엔트포인트를 폐기하는 것은 신중하게 진행해야하며, 사용자의 요청을 확인하는 방법을 구체적으로 계획해야 한다.
- 앱 버전 단위로 사용 상태를 추적해야 한다. 세 개 이상의 이전 버전을 사용중인 사용자의 비율이 얼마나 되는지 확인해야 하며, 해당 데이터를 바탕으로 구형 버전에서 어느 정도의 노력을 기울여야 하는지 결정하는 것이 용이하다.
- 클라이언트 사이드를 모니터링 하고 알림을 둬야 한다. 이러한 경고는 모바일 담당자 또는 일반 담당자에게 전달될 수 있다.
- 적어도 주요 업데이트에 대해서는 업그레이드 테스팅을 고려해봐야한다. 업그레이드 테스팅은 비용이 많이 들고, 자동화하기 어렵다. 또한 시험해야 할 여러 가지 조합이 있을 수 있다. 이 같은 이유로 테스트 비용이 많이 들어 거의 수행하지 않는 경우가 많다.

---

#### 4. DeepLinks
딥링크는 앱의 특정 부분을 열기 위해 제공되는 웹 또는 디바이스 링크이며, 이는 모바일 플랫폼에서 까다로운 문제가 된다. iOS, AOS 둘다 이를 위한 API를 제공하지만, 이에 대한 네이티브 프레임워크나 추천 방법은 업다. 한 기사에서는 "딩링크는 보아일에서 해결해야 할 가장 과소평가된 문제 중 하나 (Deep Linking is one of the most underestimated problems to solve on mobile" 이라고 언급했다. 

다음은 딥링크를 어렵게 만드는 몇 가지 이유가 있다. 
- 하위 호환성: 이전 버전에서도 딥링크가 정상적으로 동작하도록 해야 한다.
- 현재 상태를 갖고 있는 앱에서 딥링크로 링크를 열 때. 예를 들어 앱에서 디테일 페이지에 위치하고, 이메일 앱에서 다른 디테일 페이지를 가리키는 딥링크를 탭하는 경우. 현재 상태를 유지하면서 새로운 디테일 페이지가 네비게이션 스택에 추가 또는 상태를 초기화 해야 될까? 대부분의 솔루션은 상태를 초기화 하는 방법이다. 그러나 문제가 발생하지 않아야 할 플로우도 있기 때문에 신중하게 계획해야 한다.
- iOS와 AOS 간 딥링크 구현 방법이 다르기 때문에. `Firebase Dynamic Links` 또는 `Branch`와 같은 라이브러리를 사용하면 하나의 인터페이스로 작업을 추상화 할 수 있다.
- 사전 계획이 부족한 경우. 딥링크는 여러 버전이 출시된 후에 고려되는 경우가 많다. 웹과 달리 딥링크를 추가하는 것은 간단하지 않으므로, 딥링크 전략을 후반부에 추가하는 것은 엔지니어적 도전이다. 딥링크는 상태 관리 및 탐색 아키텍처와 관련이 있다.

딥링크의 가장 큰 문제는 iOS나 AOS에서 설계하고 테스트하는 방법에 대해 명확한 접근 방식을 제공하지 않는다는 것이다. 딥링크의 수가 증가하면, 이를 계속 동작시키는 데 필요한 노력과 복잡성이 급증한다. 합리적이면서 확장 가능한 딥링크 구현을 구축하기 위해서는 미리 잘 계획하는 것이 필요하다.

---

#### 5. Push And Background Notifications
앱 푸시 알림은 알림, 커뮤니케이션, 마케팅 툴로 빈번히 사용된다. 사업은 푸시를 사용하는 것을 좋아하며, 앱 개발자로서 이 방법을 지원하도록 요청받을 가능성이 높다. 하지만 푸시 알림을 구현하는데 문제점이 있다. 

푸시 알림을 세팅하는 것은 복잡하다. iOS, AOS 둘다 너의 앱은 토큰을 가져와 백엔드에 저장해야 한다. 푸시 알림을 작동시키기 위해 많은 단계가 필요하다. 

푸시 알림 요청은 백엔드에서 진행되어야 하며, 백엔드 팀과 함꼐 어떤 타입의 알림을 보낼것인지 결정해야 한다. 백엔드 팀은 모바입 푸시 알림 인프라 및 기능을 익혀 최대한 활용할 수 있도록 노력해야 한다. 

이메일 및 문자와 함께 푸시 알림을 사용하는 것은 매우 유명한 마케팅 전략이다. 이론적으로 이런 용도는 iOS 앱 가이드라인에 위반될 가능성이 있지만, 대부분의 앱에서 사용된다. 푸시 알림을 직접 구현하는 대신, 비슷하게 타사 서비스를 사용할 수도 있다. 

푸시 알림은 문제가 많으며 구현하는 것 뿐만 아니라 추가적인 문제를 야기할 수 있다. 

- 어떤 액션이 트리거 되어야 하는지 구현하는데 딥링크와 비슷한 문제가 있다. 푸시 알림은 딥링크와 내부적으로 유사하며, 백워드 호환성과 상태 문제, 추후 상황에 대한 계획등이 모두 적용된다. (Thinking about backwoard compatibility, state problems, and planning ahead all apply to push notifications as well)
- 상요자가 수신을 거부할 수 있다. iOS와 AOS 에서는 사용자가 수신 거부 또는 동의한 경우를 감지하는 방법과 한계가 있다. iOS의 경우 사용자가 알림을 거부했더라도, `silent background Notification`을 보낼 수 있다. 사용자가 푸시 알림을 수신할 수 없을 수도 있으므로, 푸시 알림은 일반적으로 어플리케이션에서 중요하지 않다고 여겨지는 부분이다.
- 푸시 알림이 성공적으로 전달됨을 보장되지 않는다. 특히 대량으로 보낼 때 푸시 알림을 제한할 수 있다. 이러한 제한 규칙은 불분명하다. 하지만 디바이스 연결 문제와 OS가 최근에 활동하지 않은 앱에 대해 알림을 제한할 수 있으므로 알림을 수신하지 못할 수도 있다.

푸시 알림을 테스트 하는 것 또한 하나의 도전이다. 시뮬레이터를 통해 수동으로 테스트를 해볼 수는 있다. 하지만 자동화된 테스트에서 이를 테스트 하기 위해서는 UI에 대한 end-to-end 테스트를 진행해야 하며, 이는 비용이 많이 든다. 

iOS에서 백그라운드 알림은 사용자에게 노출되지 않으며 직접 앱에 전달되는 푸시 메세지의 특수한 유형이다. 이러한 유형은 백엔드 업데이트를 클라이언트에게 동기화하는 데 유용하다. 이러한 종류의 알림은 동기화된 백엔드 알림 사용시 유용하다(These kinds of notifications are useful to sync backend updates to the client). 이러한 알림을 AOS에서는 `Data Message`라고 부르며, iOS에서는 `background Notificiation`이라고 부른다. 

백그라운드 알림은 실시간 및 벌티 디바이스 시나리오에 유용하다. 앱이 이 영역에 있으면 iOS와 AOS 용 크로스 플랫폼 솔루션을 구현하고, 모바일 앱이 서버를 폴링하는 대신 서버가 백그라운드 푸시 알림을 통해 데이터를 클라이언트에 보내도록 할 수 있다. 

백그라운드 알림은 아키텍처 및 비즈니스 로직을 간단하게 만들 수 있지만, 알림 전송 문제, 메세지 순서 문제, 오프라인 시나리오에 대한 로컬 데이터 캐싱과 결합해야 한다.

---

#### 6. App Crashes
앱 충돌은 모바일 앱에서 가장 눈에 띄는 버그 중 하나이며, 비즈니스에 큰 영향을 미친다. 유저는 핵심 플로우를 완료하지 못하고, 앱 사용을 중단하거나, 좋지않은 리뷰를 남기고 떠날수도 있다.

충돌은 모바일 전용 문제가 아니다. 백엔드 파트에서 주요한 포커스로, 잡을 수 없는 예외나 500 상태 코드를 모니터링 하는 것이다. 웹은 샌드박스 충돌 내의 단일 스레드 실행은 모바일 앱보다 드물다. 

충돌의 첫 번째 규칙은 충돌이 언제 발생하는지 추적하고, 충분한 디버그 정보를 가지고 있어야 한다. 충돌을 추적하며 세션의 몇 퍼센트가 충돌하는지 보고하고 이 숫자를 최대한 줄이고 싶어할 것이다. 

충돌 보고를 직접 구현하거나, 별도의 솔루션 제품을 사용할 수 있다. 대부분의 팀은 네이티브 앱을 위해 `Crashlytics` 또는 `Bugsnag` 같은 솔루션 중 하나를 선택한다. 

iOS에서 충돌 보고서(Crash Reports)는 로그를 매핑하는 데 사용할 수 있는 모든 충돌과 함께 장치에 생성된다. 애플은 개발자가 테스트플라이트나 앱스토어를 통해 이 정보를 공유하기로 선택한 사용자로부터 충돌 로그를 수집할 수 있는 방법을 제공한다. 이 접근 방식은 더 작은 앱에 충분히 잘 작동한다. 

안드로이드에서 구글 플레이스토어는 또한 개발자들이 구글 플레이 손솔에서 안드로이드 바이탈을 통해 충돌 스택 추적을 볼 수 있게 해주며, 애플과 마찬가지로 개발자에게 버그 보고서를 보내기로 선택한 사용자만 이 포털에 로그를 남길 수 있다. 

타사 라이브러리(Third Party) 또는 직접 만든(Custom-built) 충돌 보고 솔루션은 앱스토어와 구글 플레이스토어가 제공하는 것 외에도 몇 가지 이점을 얻을 수 있으며 다음과 같다.

- 더 많은 정보: 충돌로 이어질 수 있는 더 많은 정보를 제공받을 수 있다.
- 풍부한 보고: 타사 라이브러리는 일반적으로 보고서 그룹화 및 iOS 및 안드로이드 충돌률 비교를 제공한다.
- 모니터링 및 경고: 새로운 유형의 충돌이 나타나거나 특정 충돌이 급증할 때 알림을 받도록 설정할 수 있다.
- 개발 스택과의 통합: 새로운 충돌과 관련해 ticketing System(지라?), 또는 풀 리퀘스트로 참고할 수 있다.

타사 라이브러리의 단점은 충돌 및 치명적이지 않은 오류에 대한 정보만 수집할 뿐, 앱이 응답하지 않거나 메모리 문제같은 것은 포함하지 않는다. 많은 앱을 가진 조직은 보고가 충분히 풍부하지 않다는 것을 알 수 있으며, 많은 앱의 건강 상태를 비교하기 위해 자체 시스템을 만드록 싶을 수도 있다. 또한 사내 프로젝트 관리 및 코딩 툴과 저 잘 통합하는 것도 커스텀 할 이유가 된다. 

충돌의 재현성과 디버깅 가능성은 백엔드나 웹보다 모바일에 더 많은 영향을 미치는 문제다. 특히 안드로이드 세계에서 사용자는 다양한 앱 버전으로 다양한 OS 버전을 실행하는 다양한 장치를 가지고 있다. 시뮬레이터나 다른 장치에서 충돌을 재현할 수 있다면, 문제를 해결하지 않을 변겸의 여지가 없다. 하지만 특정 기기에서만 충돌이 난다면 어떻게 해야할까?

임계값을 정의하기 위해 우선 순위 지정 프레임워크를 마련하여 충돌을 조사하고 수정하는데 시간을 할애해야한다. 이 임계값은 충돌의 성격(nature of the crash), 고객 평생 가치 및 기타 비즈니스 고려 사항에 따라 달라질 것이다. 

수정의 장점과 비교하여 조사 및 수정 비용과 수익 창출 기능 구축과 같은 다른 것에 시간을 소비하는 엔지니어의 기회 비용을 비교해야 한다. 

앱 안정성은 퇴행하지 않도록 하기 위해 결국 측정하고 싶은 지표다. 앱이 결코 충돌이 없어야겠지만, 1,000개의 세션 중 1개 미만이 영향을 받는다는 것을 의미하는 안정성 수준으로 충돌을 줄일 수 있다면, 당신은 올바른 길을 가고 있는 것이다. 총 사용자 세션을 기반으로 앱 안정성 점수를 게샇나고, 목표를 달성할 때까지 충돌을 줄이는 데 시간을 투자하는 것을 목표로 해야한다. 

`Bugsnag`은 평균 앱 안정성 점수의 지표를 발표했다. 
- 1~10명의 엔지니어가 만든 경우 99.4%
- 11~50명의 엔지니어가 만든 경우 99.6%
- 51~100명의 엔지니어가 만든 경우 99.89%
- 100+명의 엔지니어가 만든 경우 99.79%

만약 앱 안정성이 99.99% 이상인 경우 해당 앱은 경쟁에서 훨씬 앞서있으며, 세계적 수준의 신뢰성으로 간주될 것이다. 




