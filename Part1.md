### PART1: Challenges due to the nature of mobile applications

앱 개발 경험이 없는 사람들은 네이티브 앱 개발이 웹 개발과 비슷할 것이라 생각하지만 그렇지 않다.

웹 혹은 백엔드와 다르게, 앱의 이진 배포(binary distribution of mobile apps), 낮은 전력 소모(low connectivity setup), 앱 푸시, 딥 링크, 인앱 결제 등 기능을 통합해야 한다.

---

#### 1. State Management

네이티브 개발에 있어 상태관리는 복잡하다. 모던 웹, 백엔드도 비슷하지만, 네이티브 개발에서는 앱의 `app lifeCycle events`, `화면 전환`을 신경써야 한다. 라이프 사이클과 관련한 예시로, 
앱이 일시정지 또는 백그라운드로 이동한 후, 포그라운드로 돌아오거나 중단되는 경우가 있다. (the app pausing and going to the background, the returning to the foreground or being suspened)

`이벤트`는 대부분의 앱에서 상태 변화를 일으키며, '상태 변경', '네트워크 요청', '유저 인풋' 같은 비동기 방식으로 트리거 된다. 대부분의 버그 또는 앱 크래쉬는 `이벤트`와 `앱 상태 붕괴`로 발생하며, 상태가 붕괴되는 문제는
전역(global) 또는 지역(local) 상태가 서로 알려지지 않은 여러 구성 요소에 의해 조작되는 앱의 일반적인 문제이다. 이러한 문제를 겪는 팀은 컴포넌트와 앱의 상태를 분리하고(isolate component and application state),
반응형 상태 관리(reactive state management)를 도입해야 한다.

`반응형 프로그래밍(Reactive Programming)`은 크고, 상태를 관리하기 위한 앱에서, 상태 변경을 격리시키기 위해 선호되는 프로그래밍 방식이다. 상태를 가능한한 변하지 않도록 유지하고, 모델을 상태 변화를 방출하는 불변의 객체로 저장한다.
`컴포넌트 트리 아래(down a tree of components)`방향으로 상태를 변경해 나가는 과정이 지루할 수 있지만, 지루함은 컴포넌트에서 의도하지 않은 상태 변경을 만들기 어렵게 한다.

같은 자원을 공유하는 앱과 짧은 시간에 OS Killing 앱은 모바일 개발을 위한 것과 백엔드 또는 웹 개발을 위한 개발에 두 가지 큰 차이가 있다. OS는 'CPU', '메모리', '에너지 소비'를 모니터링 한다. 만약 특정 앱이 많은 리소스를 활용하고 있다고 OS가 판단한다면, 약간의 경고(little warning)로 종료될 수 있다. **이것은 앱의 상태 변경에 대응하고, 상태를 저정하고, 앱을 실행 중인 곳으로 복원 하는 앱 개발자의 책임이다.** iOS 에서 이것을 상태를 관리하고, 그 사이의 전환을 처리하는 것을 의미한다(On iOS, this means handling app states and transitions between them)

권한, 블루투스와 같은 전역적인 앱 상태는 도전 과제를 제시한다. 하나의 전역 상태가 바뀔 때마다 네트워크 연결이 끊어지면 앱의 다른 부분은 다르게 반응해야할 수도 있다.
전역 상태와 함께 특정 컴포넌트가 상태 변화를 듣도록 결정되어야 한다. 하나의 스팩트럼의 앱의 화면 또는 컴포넌트는 전역 상택의 변화를 들을 수 있다. 이로 인해 많은 코드 중복이 발생하지만, 컴포넌트는 전역 상태를 핸들링 한다(components handling all of the global state concerns).
결과적으로 컴포넌트는 특정 글로벌 상태 변화를 듣고 이를 앱의 특정 부분으로 전달할 수 있다. 이것은 덜 복잡한 코드의 결과가 되지만, 전역 상태 관리와 그것을 알고 있는 컴포넌트 사이 심한 결합(tight coupling)을 가지고 있다. 

딥링크, 또는 내부 네비게이션(internal shortcut navitaion points) 또한 앱 상태 관리에 복잡성을 더한다. 딥링크를 예로 들면, 딥링크가 활성화 된 후 앱의 상태를 설정해야 할 수도 있다. 

---

#### 2. Mistakes Are Hard To Revert

모바일 앱은 바이너리 파일로 구성되어 배포된다. 클라이언트 파트 버그가 있는 버전으로 유저가 업데이트를 진행하면, 유저는 새로운 버전이 업데이트되기까지 해당 버전에 갇히게 된다. 

애플과 구글 모두 앱으로 실행 가능한 코드를 전송하는 것에 엄격한 제한을 두고 있다. 애플은 앱스토어 가이드 라인에서 기능을 변경하는 코드를 실행시키는 것을 금지하며, 구글은 프로그램 정책에 따라 관련 없는 실행 가능한 코드를 악성 코드로 간주한다.
그러나, 잘못된 버그를 되돌리는 기능은 양쪽 스토어의 정책에 포함되어야 한다. 또한 애플을 자바스크립트같은 네이티브 코드가 아닌 코드도 허용하고 있으며, `코드 푸시(CodePush)` 와 같은 솔루션이 인기있는 이유다.
코드 푸시는 `React Native`, `Cordova` 앱이 즉시 업데이트 될 수 있도록 허용한다. 우버에서 우리는 자체 솔루션을 구축했다. 

- 새로운 앱을 배포하는데까지는 며칠이 걸린다. 애플의 경우 모든 앱에 대해 수동 검토가 이뤄지며, 이는 24~48 시간 정도가 걸리며, 모든 앱은 리젝 당할 수 있다. 2020.06을 기준으로 애플은 가이드라인 위반으로 법적 문제를 제외하고, 버그 수정이 더 이상 지연되지 않는 방침을 변경했다. 
- 사용자들은 스토어에 새로운 버전이 배포된 이후, 실제 신규 버전을 배포 받기 까지 며칠이 걸리며, 이는 자동 업데이트가 켜져 있는 사용자도 마찬가지다. 
- 모든 사용자가 이 업데이트된 버전을 받을 것이라고 가정할 수 없다. 몇몇 유저는 자동 업데이트를 비활성화 했을 수도 있으며, 업데이트를 하더라도 몇몇개의 버전을 건너뛸 수 있다. 

```
it was the most terrifying thing to take 10,000 diffs, package it into effectively a bullet,
fire that bullet at the horizon and that bullet once it leaves the barrel, it's gone.
i cannot get it back, and it flies flat and true with no friction and to gravity till the heat death of the universe.
it's gone. i can't fix it
```

이는 앱의 모든 이전 버전이 무기한으로 지원되어야 함을 의미하며, 지원하도록 만들어야 한다. 유일한 예외는 자체 제작 컨토롤을 도입하고, 과거 버전을 지원하기 위해 강제 업데이트 메커니즘을 구축하는 경우다. 
안드로이드의 경우 `Play Core`라이브러리에서 앱 내 업데이트를 지원하지만, iOS는 비슷한 내장 지원 기능을 가지고 있지 않다.

수백만명의 사용자가 있는 앱이 있다고 가정하면, 이전 버전에서 발생하는 버그나 회귀를 최소화하기 위해 어떤 조치를 취할 수 있을까?

- 모든 레벨의 테스트를 진행하라(Do Thorough testing at all levels). 자동 테스트 매뉴얼 테스트, 그리고 쉬운 피드백을 받을 수 있는 베타 테스트까지. 많은 회사의 일반적인 접근 방식은 일주일 동안 사용해 볼 수 있도록
  베타 앱을 출시하고 모든 문제에 대한 피드백을 수집하는 것이다.
- 기능 플래그 시스템을 갖추고 있으므로, 버그를 되돌릴 수 있다. 여전히 기능 플래그는 더 많은 문제점을 더한다.
- 예상대로 작동하도록 모니터링과 함께 점진적인 규칙울 고려해라.
- 강제 업데이트는 강력한 솔루션이지만, 이를 실행하기 위해서는 고려해야 하며, 이 과정에서 몇몇 고객들이 떠날 수도 있다.

---

#### 3. The Long Tail Of Old App Versions

오래된 앱 버전은 최대 몇 년 동안 유지되며, 엄격한 강제 업데이트 정책을 시행하는 몇몇 팀인 경우에만 짧게 유지될 것이다. 

대부분의 사용자는 며칠 안에 새로운 앱 버전으로 업데이트 하지만, 여러 버전이 뒤쳐진 사용자가 있을 것이다. 일부 사용자는 의도적으로 자동 업데이트를 비활성화 하지만, 오래된 기기 또는 OS로 인해 사용이 불가능해진다.
또한 오래된 앱 버전은 보수가 적은 많은 노력이기 때문에 정기적으로 테스트 되지 않는다. 

깨지지 않는 백엔드(서버)의 변경 조차도 특정 응답의 내용을 변경하는 것 처럼 오래된 버전을 깨뜨릴 수 있다. 이러한 크래쉬를 피하기 위한 몇 가지 방법이 있다. 

- 전용 도구를 사용해 네트워크 응답 처리 및 파싱을 견고하게 구축해야한다. `GraphQL`과 같이 클라이언트와 백엔드 간에 생성된 더 강력하고 형식화된 것을 선호한다. 이는 수동으로 유효성을 검사해야하는 `REST` 인터페이스보다 훨씬 더 나은 방법으로, 누군가 모바일에서 파싱 로직을 업데이트를 잊어버린 경우 `REST` 인터페이스에서 예기지 않은 오류가 발생할 수 있다.
- 백엔드 변경을 깨기 위해 미리 계획해야 한다. 백엔드 팀과 열린 커뮤티케이션을 가져라. 오래된 앱을 테스트 할 수 있는 방법이 있다. 강제 업그레이드가 모든 현재 앱 사용자를 이전 엔드포인트에서 옮길 때까지 새로운 엔드포인트를 구축하고 오래된 엔트포인트를 폐기하지 않는 것을 고려해야 한다.
- 벡엔드 엔드포인트의 버전을 관리할 때, 호환성에 영향을 미치는 변경사항이 있을 경우 기존 엔드포인트를 폐기하고 새로운 버전의 엔드포인트를 만드는 것이 일반적이다. 
- 백엔드 엔드포인트를 폐기하는 경우, 트래픽을 모니터링하고 필요한 경우 요청을 효율적으로 전달할 수 있는 마이그레이션 계획이 필요하다. 엔트포인트를 폐기하는 것은 신중하게 진행해야하며, 사용자의 요청을 확인하는 방법을 구체적으로 계획해야 한다.
- 앱 버전 단위로 사용 상태를 추적해야 한다. 세 개 이상의 이전 버전을 사용중인 사용자의 비율이 얼마나 되는지 확인해야 하며, 해당 데이터를 바탕으로 구형 버전에서 어느 정도의 노력을 기울여야 하는지 결정하는 것이 용이하다.
- 클라이언트 사이드를 모니터링 하고 알림을 둬야 한다. 이러한 경고는 모바일 담당자 또는 일반 담당자에게 전달될 수 있다.
- 적어도 주요 업데이트에 대해서는 업그레이드 테스팅을 고려해봐야한다. 업그레이드 테스팅은 비용이 많이 들고, 자동화하기 어렵다. 또한 시험해야 할 여러 가지 조합이 있을 수 있다. 이 같은 이유로 테스트 비용이 많이 들어 거의 수행하지 않는 경우가 많다.

---

#### 4. DeepLinks
딥링크는 앱의 특정 부분을 열기 위해 제공되는 웹 또는 디바이스 링크이며, 이는 모바일 플랫폼에서 까다로운 문제가 된다. iOS, AOS 둘다 이를 위한 API를 제공하지만, 이에 대한 네이티브 프레임워크나 추천 방법은 업다. 한 기사에서는 "딩링크는 보아일에서 해결해야 할 가장 과소평가된 문제 중 하나 (Deep Linking is one of the most underestimated problems to solve on mobile" 이라고 언급했다. 

다음은 딥링크를 어렵게 만드는 몇 가지 이유가 있다. 
- 하위 호환성: 이전 버전에서도 딥링크가 정상적으로 동작하도록 해야 한다.
- 현재 상태를 갖고 있는 앱에서 딥링크로 링크를 열 때. 예를 들어 앱에서 디테일 페이지에 위치하고, 이메일 앱에서 다른 디테일 페이지를 가리키는 딥링크를 탭하는 경우. 현재 상태를 유지하면서 새로운 디테일 페이지가 네비게이션 스택에 추가 또는 상태를 초기화 해야 될까? 대부분의 솔루션은 상태를 초기화 하는 방법이다. 그러나 문제가 발생하지 않아야 할 플로우도 있기 때문에 신중하게 계획해야 한다.
- iOS와 AOS 간 딥링크 구현 방법이 다르기 때문에. `Firebase Dynamic Links` 또는 `Branch`와 같은 라이브러리를 사용하면 하나의 인터페이스로 작업을 추상화 할 수 있다.
- 사전 계획이 부족한 경우. 딥링크는 여러 버전이 출시된 후에 고려되는 경우가 많다. 웹과 달리 딥링크를 추가하는 것은 간단하지 않으므로, 딥링크 전략을 후반부에 추가하는 것은 엔지니어적 도전이다. 딥링크는 상태 관리 및 탐색 아키텍처와 관련이 있다.

딥링크의 가장 큰 문제는 iOS나 AOS에서 설계하고 테스트하는 방법에 대해 명확한 접근 방식을 제공하지 않는다는 것이다. 딥링크의 수가 증가하면, 이를 계속 동작시키는 데 필요한 노력과 복잡성이 급증한다. 합리적이면서 확장 가능한 딥링크 구현을 구축하기 위해서는 미리 잘 계획하는 것이 필요하다.

---

#### 5. Push And Background Notifications
앱 푸시 알림은 알림, 커뮤니케이션, 마케팅 툴로 빈번히 사용된다. 사업은 푸시를 사용하는 것을 좋아하며, 앱 개발자로서 이 방법을 지원하도록 요청받을 가능성이 높다. 하지만 푸시 알림을 구현하는데 문제점이 있다. 

푸시 알림을 세팅하는 것은 복잡하다. iOS, AOS 둘다 너의 앱은 토큰을 가져와 백엔드에 저장해야 한다. 푸시 알림을 작동시키기 위해 많은 단계가 필요하다. 

푸시 알림 요청은 백엔드에서 진행되어야 하며, 백엔드 팀과 함꼐 어떤 타입의 알림을 보낼것인지 결정해야 한다. 백엔드 팀은 모바입 푸시 알림 인프라 및 기능을 익혀 최대한 활용할 수 있도록 노력해야 한다. 

이메일 및 문자와 함께 푸시 알림을 사용하는 것은 매우 유명한 마케팅 전략이다. 이론적으로 이런 용도는 iOS 앱 가이드라인에 위반될 가능성이 있지만, 대부분의 앱에서 사용된다. 푸시 알림을 직접 구현하는 대신, 비슷하게 타사 서비스를 사용할 수도 있다. 

푸시 알림은 문제가 많으며 구현하는 것 뿐만 아니라 추가적인 문제를 야기할 수 있다. 

- 어떤 액션이 트리거 되어야 하는지 구현하는데 딥링크와 비슷한 문제가 있다. 푸시 알림은 딥링크와 내부적으로 유사하며, 백워드 호환성과 상태 문제, 추후 상황에 대한 계획등이 모두 적용된다. (Thinking about backwoard compatibility, state problems, and planning ahead all apply to push notifications as well)
- 상요자가 수신을 거부할 수 있다. iOS와 AOS 에서는 사용자가 수신 거부 또는 동의한 경우를 감지하는 방법과 한계가 있다. iOS의 경우 사용자가 알림을 거부했더라도, `silent background Notification`을 보낼 수 있다. 사용자가 푸시 알림을 수신할 수 없을 수도 있으므로, 푸시 알림은 일반적으로 어플리케이션에서 중요하지 않다고 여겨지는 부분이다.
- 푸시 알림이 성공적으로 전달됨을 보장되지 않는다. 특히 대량으로 보낼 때 푸시 알림을 제한할 수 있다. 이러한 제한 규칙은 불분명하다. 하지만 디바이스 연결 문제와 OS가 최근에 활동하지 않은 앱에 대해 알림을 제한할 수 있으므로 알림을 수신하지 못할 수도 있다.

푸시 알림을 테스트 하는 것 또한 하나의 도전이다. 시뮬레이터를 통해 수동으로 테스트를 해볼 수는 있다. 하지만 자동화된 테스트에서 이를 테스트 하기 위해서는 UI에 대한 end-to-end 테스트를 진행해야 하며, 이는 비용이 많이 든다. 

iOS에서 백그라운드 알림은 사용자에게 노출되지 않으며 직접 앱에 전달되는 푸시 메세지의 특수한 유형이다. 이러한 유형은 백엔드 업데이트를 클라이언트에게 동기화하는 데 유용하다. 이러한 종류의 알림은 동기화된 백엔드 알림 사용시 유용하다(These kinds of notifications are useful to sync backend updates to the client). 이러한 알림을 AOS에서는 `Data Message`라고 부르며, iOS에서는 `background Notificiation`이라고 부른다. 

백그라운드 알림은 실시간 및 벌티 디바이스 시나리오에 유용하다. 앱이 이 영역에 있으면 iOS와 AOS 용 크로스 플랫폼 솔루션을 구현하고, 모바일 앱이 서버를 폴링하는 대신 서버가 백그라운드 푸시 알림을 통해 데이터를 클라이언트에 보내도록 할 수 있다. 

백그라운드 알림은 아키텍처 및 비즈니스 로직을 간단하게 만들 수 있지만, 알림 전송 문제, 메세지 순서 문제, 오프라인 시나리오에 대한 로컬 데이터 캐싱과 결합해야 한다.

---

#### 6. App Crashes
앱 충돌은 모바일 앱에서 가장 눈에 띄는 버그 중 하나이며, 비즈니스에 큰 영향을 미친다. 유저는 핵심 플로우를 완료하지 못하고, 앱 사용을 중단하거나, 좋지않은 리뷰를 남기고 떠날수도 있다.

충돌은 모바일 전용 문제가 아니다. 백엔드 파트에서 주요한 포커스로, 잡을 수 없는 예외나 500 상태 코드를 모니터링 하는 것이다. 웹은 샌드박스 충돌 내의 단일 스레드 실행은 모바일 앱보다 드물다. 

충돌의 첫 번째 규칙은 충돌이 언제 발생하는지 추적하고, 충분한 디버그 정보를 가지고 있어야 한다. 충돌을 추적하며 세션의 몇 퍼센트가 충돌하는지 보고하고 이 숫자를 최대한 줄이고 싶어할 것이다. 

충돌 보고를 직접 구현하거나, 별도의 솔루션 제품을 사용할 수 있다. 대부분의 팀은 네이티브 앱을 위해 `Crashlytics` 또는 `Bugsnag` 같은 솔루션 중 하나를 선택한다. 

iOS에서 충돌 보고서(Crash Reports)는 로그를 매핑하는 데 사용할 수 있는 모든 충돌과 함께 장치에 생성된다. 애플은 개발자가 테스트플라이트나 앱스토어를 통해 이 정보를 공유하기로 선택한 사용자로부터 충돌 로그를 수집할 수 있는 방법을 제공한다. 이 접근 방식은 더 작은 앱에 충분히 잘 작동한다. 

안드로이드에서 구글 플레이스토어는 또한 개발자들이 구글 플레이 손솔에서 안드로이드 바이탈을 통해 충돌 스택 추적을 볼 수 있게 해주며, 애플과 마찬가지로 개발자에게 버그 보고서를 보내기로 선택한 사용자만 이 포털에 로그를 남길 수 있다. 

타사 라이브러리(Third Party) 또는 직접 만든(Custom-built) 충돌 보고 솔루션은 앱스토어와 구글 플레이스토어가 제공하는 것 외에도 몇 가지 이점을 얻을 수 있으며 다음과 같다.

- 더 많은 정보: 충돌로 이어질 수 있는 더 많은 정보를 제공받을 수 있다.
- 풍부한 보고: 타사 라이브러리는 일반적으로 보고서 그룹화 및 iOS 및 안드로이드 충돌률 비교를 제공한다.
- 모니터링 및 경고: 새로운 유형의 충돌이 나타나거나 특정 충돌이 급증할 때 알림을 받도록 설정할 수 있다.
- 개발 스택과의 통합: 새로운 충돌과 관련해 ticketing System(지라?), 또는 풀 리퀘스트로 참고할 수 있다.

타사 라이브러리의 단점은 충돌 및 치명적이지 않은 오류에 대한 정보만 수집할 뿐, 앱이 응답하지 않거나 메모리 문제같은 것은 포함하지 않는다. 많은 앱을 가진 조직은 보고가 충분히 풍부하지 않다는 것을 알 수 있으며, 많은 앱의 건강 상태를 비교하기 위해 자체 시스템을 만드록 싶을 수도 있다. 또한 사내 프로젝트 관리 및 코딩 툴과 저 잘 통합하는 것도 커스텀 할 이유가 된다. 

충돌의 재현성과 디버깅 가능성은 백엔드나 웹보다 모바일에 더 많은 영향을 미치는 문제다. 특히 안드로이드 세계에서 사용자는 다양한 앱 버전으로 다양한 OS 버전을 실행하는 다양한 장치를 가지고 있다. 시뮬레이터나 다른 장치에서 충돌을 재현할 수 있다면, 문제를 해결하지 않을 변겸의 여지가 없다. 하지만 특정 기기에서만 충돌이 난다면 어떻게 해야할까?

임계값을 정의하기 위해 우선 순위 지정 프레임워크를 마련하여 충돌을 조사하고 수정하는데 시간을 할애해야한다. 이 임계값은 충돌의 성격(nature of the crash), 고객 평생 가치 및 기타 비즈니스 고려 사항에 따라 달라질 것이다. 

수정의 장점과 비교하여 조사 및 수정 비용과 수익 창출 기능 구축과 같은 다른 것에 시간을 소비하는 엔지니어의 기회 비용을 비교해야 한다. 

앱 안정성은 퇴행하지 않도록 하기 위해 결국 측정하고 싶은 지표다. 앱이 결코 충돌이 없어야겠지만, 1,000개의 세션 중 1개 미만이 영향을 받는다는 것을 의미하는 안정성 수준으로 충돌을 줄일 수 있다면, 당신은 올바른 길을 가고 있는 것이다. 총 사용자 세션을 기반으로 앱 안정성 점수를 게샇나고, 목표를 달성할 때까지 충돌을 줄이는 데 시간을 투자하는 것을 목표로 해야한다. 

`Bugsnag`은 평균 앱 안정성 점수의 지표를 발표했다. 
- 1~10명의 엔지니어가 만든 경우 99.4%
- 11~50명의 엔지니어가 만든 경우 99.6%
- 51~100명의 엔지니어가 만든 경우 99.89%
- 100+명의 엔지니어가 만든 경우 99.79%

만약 앱 안정성이 99.99% 이상인 경우 해당 앱은 경쟁에서 훨씬 앞서있으며, 세계적 수준의 신뢰성으로 간주될 것이다. 

---

#### 7. Offline Support
오프라인 지원은 풍부한 웹 어플리케이션 기능이 되고 있지만, 네이티브 모바일 앱에서는 핵심기능이다. 사람들은 신호가 약해지거나 연결이 끊어지더라도 앱을 계속 사용할 수 있기를 기대한다. 

적절한 오프라인 모드 지원은 앱에 많은 복잡성과 예상치 못한 예외 상황을 추가한다.

- 휴대폰이 오프라인 상태인지 신뢰성 있게 감지하는 것은 중요하다. 운영체제는 사용자가 온라인 상태임을 보고할 수 있지만, 이는 항상 사실이 되지 않을 수 있다. 휴대폰이 `captive portals`을 사용하는 Wi-Fi 지점에 연결되면 데이터가 전송되지 않을 수도 있으며, 이과 같은 예외적인 상황에서 앱은 몇 개의 `always online` 핑을 도메인에 보내 확인할 수 있다.
- 연결 속도와 지연 시간을 감지하고 필요한 경우 앱의 동작은 변경하는 것은 중요하다. 스트리밍 앱은 사용 가능한 대역폭에 맞게 스트림을 최적화한다. 다른 앱은 앱에 방해가 되는 연결 불안정성에 대해 사용자에게 경고할 수 있으며, 이러한 예외 상황을 처리하는 방식에 대해 미리 계획을 세워야 한다.
- 기기가 오프라인 상태일 떄 로컬 상태를 유지하고, 다시 연결이 되면 동기화하는 것은 중요하다. 사용자가 온라인 또는 오프라인인 여러 기기에서 앱을 사용하는 경우 `경합 조건(Race Condition)`을 고려해야 한다. 로컬에 저장된 데이터를 수정하는 앱 업데이트에 대해서는 기존 데이터를 새로운 형식으로 마이그레이션하는 것에 대해 추가적인 주의가 필요하다.

어떤 기능이 오프라인에서 작동해야 하고 어떤 기능이 그렇지 않아야 할 지 결정하는 것은 중요한 단계다. 이러한 간단한 단계를 놓치는 경우 오프라인 기능의 계획이 어려워지고, 범위 확장이 발생할 수 있다. 이 경우 '앱의 주요 부분부터 시작하고 이 범위를 천천히 확장하는 것이 좋다(starting with the key parts of the application and expanding this scope slowly)'. 중요한 오프라인 모드가 예상대로 작동하는지 실제 사용자의 피드백을 받아야 한다. 이러한 접근 방식을 앱의 다른 부분에 활용할 수 있는지 살펴봐야 한다. 

오프라인 예외 상황을 처리하는 방법을 결정해야 한다. 휴대폰은 여전히 온라인 상태이지만 데이터 연결이 지나치게 느린 경우에는 어떻게 처리할지 결정해야 한다. 견고한 채결책은 이를 오프라인으로 간주하고 사용자에게 이 사실을 알릴 수 있다. 그렇다면 시간 초과 다시 시도해 처리할 것인가?

재시도는 까다로운 엣지 케이스가 될 수 있다. 일정 시간동안 응답이 없는 연결이 있는 경우 다른 요청을 재시도 한다고 가정해보자. 첫 번째 요청이 반환되고 나서 두 번째 요청도 반환된다면, 데이터 경합 조건이나 데이터 문제가 발생할 수 있다. 

동기화는 기기와 백엔드 데이터 간의 문제이며 여러 기기로 인해 복잡성이 증가하는 일반적이고 동시에 도전적인 문제다. 여러 개의 동시 오프라인 편집을 처리하고 연결이 중간에 끊어지는 상황을 견딜 수 있는 충분히 강력한 충돌 해결 프로토콜을 선택해야 한다.

```
- 재시도 전에 네트워크가 정말로 끊어진 상태인지 어떻게 확신할 수 있을까요?
- 사용자가 무작정 재시도하고 여러 개의 병렬 요청을 생성하는 상황을 어떻게 처리할까요?
- 이전 요청이 완료되지 않은 상태에서 같은 요청이 가능한가요?
- 오프라인 모드로 전환될 때, 앱은 언제 네트워크가 신뢰할만한 상태로 복구되었다고 알 수 있을까요?
- 앱은 백엔드 서비스가 응답하지 않는 것인지 아니면 네트워크가 느린 것인지 어떻게 구분할 수 있을까요?
- 자원 효율성에 대해서는 ETag 또는 if-match 헤더를 활용한 HTTP 조건부 요청과 재시도를 고려해야 할까요?
```
와 같은 물음이 생길 수 있다. 

약한 연결 상태에서는 네트워크 요청이 때떄로 시간 초과가 될 수 있다. 합리적인 재시도 전략이나 오프라인 모드로 전환하는 것이 도움이 될 수 있지만, 이때 고려해야 할 다양한 트레이드 오프가 있다. 

이전에 이야기 했던, `RxSwift` `애플의 combine`, `RxJava`, `코틀린의 코루틴`을 사용하면 네트워크 연결을 처리할 떄 비교적 간단하게 해결할 수 있다.

재시도 해서는 안되는 요청은 별도의 문제를 가지고 있다. 예를 들어 결제 요청이 진행 중인 경우, 재시도 하고 싶지 않을 수 있다. 그러나 해당 요청이 실패로 반환되면 어떻게 될까? 이 경우 이후에 재시도 하는 것이 안전하다고 생각할 수 있다. 하지만 요청이 시간 초과되었지만 서버에서 결제를 수행했다면 사용자에게 중복으로 요금이 청구될 수 있다. 

백엔드 엔드포인트의 소비자로서, 모든 엔드포인트에 대한 재시도를 안전하기 진행하기 위해 `반복해도 동일한 결과`가 나올 수 있도록 해야한다. 이러한 엔드포인트를 사용하기 위해서는 특정 키를 얻고 전송해야 하며, 추가적인 상태를 추적해야 한다. 또한 앱이 충돌하고 다시 시작되는 등의 예외 상황에 대해 걱정해야 하며, 특정 키가 영구적으로 저장되지 않을 수 있는 문제도 고려해야 한다. 안전한 재시도를 구현하는 것은 팀에게 많은 추가 작업을 요구하며 이를 위해 백엔드 팀과 긴밀히 협력하여 사용 사례를 매핑하고 설계해야 한다.

상태 관리와 마찬가지로 유지 가능한 오프라인 모드와 약한 연결 지원의 핵심은 간결함이다. 변경할 수 없는 상태, 직관적인 동기화 전략, 그리고 느린 연결을 처리하기 위한 간단한 전략을 사용해야 한다. iOS의 `Network Link Conditioner` 또는 안드로이드 에뮬레이터의 `networkSpeed` 기능과 같은 적절한 도구를 사용하여 충분히 테스트 할 수 있다. 

---

#### 8. Accessibility

접근성은 인기있는 애플리케이션에 있어, 큰 의미를 가지며 몇 가지 이유가 있다. 

1. 많은 사용자를 보유한 경우 그 중 많은 사용자가 다양한 접근성 요구사항을 가지고 있으며, 적절한 지원 없이 앱과 상호작용하기 어렵거나 불가능할 수 있다.
2. 앱이 접근성이 없다면, 앱의 배포자에게 내재적인 법적 위험이 있으며, 미국에서는 이미 몇몇 접근성 소송이 원래의 모바일 앱을 대상으로 진행중에 있다.

접근성은 단순히 좋은(nice) 일이 아니다. 더 많은 접근성을 가질 경우 앱의 퀄리티는 높아진다. 접근성을 시작하기 전에 우리는 `WCAG 2.1`의 모바일 정의를 구현할 깊이를 확인해야 한다. iOS의 `VoiceOver` 또는 안드로이드의 `TalkBack을 통해 시작 장애인이 앱을 사용할 수 있도록 하는 것과 색상, 주요 요소의 대비를 충분히 강조하는 것은 일반적인 기본 요구사항이다. 앱의 종류에 따라 청각 장애인들이나 다른 접근성 요구사항을 고려해야 할 수도 있다. 

접근성은 시작적으로 장애를 가진 사람들이 앱을 사용할 수 있게 하는 것 이상의 의미를 갖는다. 앱의 접근성 설정을 지원하여 사용자가 원하는 글꼴 크기를 동적으로 조정하도록 하는 것(iOS의 DynamicType, 안드로이드의 scale-independent pixels)은 따라야 할 관례이다. 또한 기기 분포를 고려해야 한다. 예를 들어 안드로이드의 경우 'OnePlus' 기종은 생태계의 나머지와 다른 글꼴 크기를 갖고 있다. 

접근성을 처음부터 구현하는 것은 iOS에서는 상당히 노력이 들지 않는 작업이며, 안드로이드에서도 현명한 선택이다. 두 플랫폼 모두 접근성 요구사항에 대해 심도 있게 고려하고 접근성 기능을 추가하는 것이 비교적 간편하다. 접근성을 나중에 갖추는 것은 시간이 많이 소요될 수 있는 문제이며, 접근성을 설계 과정의 일부로 만들면 계획 및 RFC 프로세스의 일환으로 만들어야 하는 좋은 아이디어이다. iOS에서는 페이지 수준의 `VoiceOver`프레임과 처음부터 접근성 모범 사례를 다르는 것은 좋은 투자이다. 

접근성을 테스트하는 것은 계획이 필요하다. 다음과 같은 몇 가지 수준의 접근성 테스트 방법이 있다.
1. 접근성 요소 중 자동화할 수 있는 부분을 자동화한다. 화면 요소에 접근성 레이블이 있는지 확인하는 것과 같은 접근성 검사를 자동화할 수 있다. iOS에서는 VoiceOver 콘텐츠를 텍스트로 표시하고 이러한 검사를 자동화하는 것도 가능하다.
2. 수동으로 접근성 기능을 테스트 해야한다. 이를 릴리스 프로세스의 일환으로 최소한 반정기적으로 수행해야 한다.
3. 접근성 사용자를 베타 프로그램에 모집하여 그들의 직접적인 피드백을 받는다. 이는 대규모 회사에게 더 쉽게 실현 가능하지만 이러한 사용자들이 엔지니어링 팀과 상호작용하는 이점이 크다.
4. 개발 중에 접근성 기능을 켜두는 것도 현명한 선택이다. 이렇게 하면 이러한 기능이 작동하는 것을 검사하고 이를 이용하는 사용자들의 관점을 더 잘 이해할 수 있다.

---

#### 9. CI/CD & The Build Train

간단한 백엔드 또는 웹 서비스의 경우 CI/CD는 간단하지만, 간단한 모바일 앱은 그렇지 않다. 이는 주로 앱 스토어의 수동 제출 단계 때문이며, iOS 앱 스토어 앱의 경우 완전 자동화된 지속적인 배포 파이프라인은 수동 검토 게이트로 인해 불가능하다. 안드로이드에서는 이 프로세스를 자동화 할 수 있다. 

iOS앱과 안드로이드 플랫폼은 서로 다르다. 각각 자체 빌드 시스템과 별도의 파이프라인이 필요하다. 타사 CI를 선택할 때는 iOS와 안드로이드 모바일 빌드를 우선적으로 처리하고, 모바일에 대한 실적이 검증된 제공자를 선택하는 것이 좋다. `Bitrise`는 모바일 엔지니어들에 의해 구촉된 모바일용 CI/CD다. PR 부터 스토어 제출까지 `Bitrise`는 앱 개발 워크플로우를 자동화하고 모니터링하며 개선합니다. `Bitrise`는 네이티브, RN, Flutter 및 기타 모바일 프레임워크를 지원하며, 테스트 코드, 서명 또는 빌드 문제가 발생했을 때, 알림과 같은 특정 개발 단계에 대한 지원이 필요한 경우, 수백 개의 통합을 제공하는 오픈 소스 라이브러리를 통해 필요한 기능을 찾거나 빠르게 구출할 수 있다. 

클라우드 기반 CI/CD 공급업체를 사용하는 것 보다 자체 빌드 인프라를 소유하는 것이 더 많은 통제력과 더 나은 경험을 제공할 수 있다. 모바일 엔지니어링 리더들은 여러 엔지니어링 기업에서 자체 빌드 인프라를 소유하는 것이 더 만족스러워한다고 언급하지만, 추가적인 추가 가격이 발생할 수 있다. 

매우 큰 규모에서는 자체적으로 구축하는 것이 선택될 수 있다. 우버에서는 우리가 수행하는 빌드 수에 대해 믿을만한 공급업체가 없었고, 자체 시스템이 제공하는 통합 훅을 제공할 수 없었다. 아마도 스스로 주요 빌드 도구를 사용해 스토어에 업로드와 같은 다양한 빌드 단계를 자동화하게 될 것이며, iOS의 경우 `Fastlane` 안드로이드의 경우, `Jenkins` 또는 비슷한 것을 사용할 것이다. 

만약 전용 인력이 이를 지원할 수 없다면, 자체적으로 구축한 CI 시스템을 유지하는데 주의해야 한다. CI 설정을 가동한 후에도 몇달 뒤에 인프라 문제를 계속 다뤄야 할 필요가 있으며, 이에 제조사 솔루션을 구매하고 인프라 부분을 제조사에게 맡기거나 모바일 빌드 인프라를 전담하는 개인 또는 팀을 두는 것을 강력히 제안한다. 

대기업의 경우 빌드 인프라를 소유하는 것이 합리적일 수 있다. 우버에서는 iOS와 안드로이드 모노레포나 마스터의 안정성을 유지하는 데 전용 모바일 인프라 팀이 있었고, 다른 대규모 모바일 팀과 충분한 자원을 가진 기업도 전용 하드웨어를 사용하여 자체적인 CI를 운영한다. 

빌드 트레인은 CI가 마련된 후 다음 단계이다. 빌드 트레인은 주간 또는 격주별 릴리스의 상태를 추적하는 방법이다. 앱 스토어의 '릴리스 후보'를 위한 릴리스 컷이 만들어진 후, 여러 유효성 검사 단계가 진행되어야 한다. 이 중에는 자동화된 것과 수동으로 해야 할 것들이 있다. 이 단계에는 모든 자동화된 테스트 실행, 수동 테스트, 새로운 리소스 로컬라이징, 성늘 테스트, 또는 독후성 테스팅 또는 베타 테스팅 기간이 포함될 수 있다. 

릴리스 후보가 검증되면 앱 스토어에 업로드되고 승인을 기다리며, 승인 후 iOS에서 달계별 롤아웃 또는 안드로이드에서 단계별 롤아웃과 같이 단계별 릴리스를 할 수 있다. 

빌드 트레인은 위애서 언급한 모든 상태를 시각화한다. 빌드 후보 컷이 어디에 있는지, 유효성 검사 프로세스가 어떤 상태인지, 단계별 롤아웃 상태가 어떤지를 보여준다. 빌드 트레인은 릴리스 프로세스를 담당하는 사람들이 수동으로 추적할 수도 있으며, 복잡한 릴리스 단계와 모바일 인프라 팀이 있는 기업들은 종종 자체적인 솔루션을 구축한다. 

전형적인 롤 아웃 단계는 다음과 같다. 
1. 앱의 개발/야간 빌드: CI/CD 시스템에서 빌드한 앱의 버전으로, 매일 밤마다 수행한다. 일반적으로 회사의 직원들이 이 빌드에만 접근할 수 있다.
2. 베타/도그푸드 릴리스: 보통 단계별 롤아웃이 시작되기 전에 대부분의 회사 직원 및 베타 테스터에게 릴리스한다. 충분한 크기의 베타 그룹은 일반 롤아웃 이전에 리그레션과 문제를 잡는 데 도움이 될 수 있다.
3. 본격적인, 단계별 운영 롤아웃: 롤아웃은 안드로이드에서 특정 인구의 백분율로 단계적으로 이뤄진다.

iOS와 안드로이드 롤아웃을 함께 결합할지, 따로 수행할지는 릴리스 팀의 선택에 달려있다. 우버에서는 단순함과 일관성을 위해 이를 함께 결합했고, 주간 릴리스 주기를 유지하며 더 상세한 릴리스 일정은 별 의미가 없었다. 

모바일 앱 릴리스 빈도는 팀 또는 회사의 결정에 따라 다르다. 모바일 릴리스마다 테스트 부담이 발생하며, 이는 상당이 중요하다. 동시에 많은 변경과 기능이 포함된 대규모 릴리스는 리그레션 가능성이 높으며, 이미 늦어진 릴리스를 더 지연시킬 수 있다. 일반적으로 기업들이 채택하는 전형적인 모바일 릴리스 일정은 다음과 같다. 
1. 주간: 안정적인 릴리스 및 테스트 프로세스를 가진 대규모 모바일 팀은 일반적으로 주간 빌드 컷 접근 방식을 따른다. 빌드 컷을 수행하고 베타 사용자에게 롤아웃한다. 리그레션이 발견되지 않으면 빌드 컷 후 일주일 후에 앱을 스토어에 올린다.
2. 격주: 많은 기업이 이 모델을 선택하여 스프린트 길이와 함께 맞추기도 하고 각 릴리스마다 발생하는 부담을 줄이기 위해 격주로 릴리스한다.
3. 덜 자주 또는 선택적 릴리스: 소규모 앱은 충분히 중요한 변경이 이루어질 때에만 릴리스할 수 있다. 이는 대규모나 복잡한 앱에는 드물게 나타난다. 덜 자주 릴리스는 종종 품질이 낮을 수 있다. 더 많은 기능이 한꺼번에 출시되고 리그레션 가능성이 높아져서 수정하는 데 더 오래 걸릴 수 있다. 앱의 품질을 개선하려면 배송 속도를 높이는 것을 고려해야 한다.

모바일 빌드 트레인은 위에서 언급한 모든 상태를 시각화하는 방법이다. 빌드 후보 컷이 어디에 있는지, 유효성 검사 프로세스가 어떤 상태인지, 단계별 롤아웃 상태가 어떤지를 보여준다. 릴리스 매니저가 빌드 트레인을 수동으로 추적할 수 있다. 복잡한 릴리스 단계와 모바일 인프라 팀이 있는 기업은 종종 자체적인 솔루션을 구축한다. 

릴리스가 준비 완료인 상태로 가기 전에 어떤 검사가 완료되어야 하는지 정의해야 한다. 이를 공식화한 후 가능한 많은 검사를 자동화할수록 릴리스 프로세스가 더 원활해진다. 

우버에서는 각 릴리스 단계에 다음과 같은 테스트가 통과해야 한다. 
1. 실패 없이 실행되는 UI테스트: UI 테스트가 충분히 크기 때문에 모든 테스트를 CI에서 실행하는 것은 논리적이지 않다. 릴리스 전에 모든 테스트가 실행된다.
2. 해당 테스트를 소유하거나 QA 팀이 소유하는 수동 정상성 테스트: 테스트가 실패하거나 테스트가 실행되지 않으면 빌드 트레인이 진행되지 않는다.
3. 모든 문자열의 로컬라이징 완료. 자동 검사를 통해 앱에 누락된 번역이 없는지 확인한다.
4. 충돌 보고서: 베타 테스팅 프로세스에서 발견된 리그레션 없으면 베타 단계에서 충돌이 발생하면 자동으로 알림이나 티켓을 트리거하고 팀은 이를 조사하고 처리애햐 롤아웃이 계속된다.
5. 메모리 사용량: 메모리 프로파일링에 따른 리그레션 없음.
6. 비즈니스 메트링: 롤아웃 도중 리그레션 없음. 우버에서는 지역별로 요청, 배차 및 탑승 신호를 모니터링했다. 버그로 인해 이러한 주요 메트릭 중 하나가 리그레션을 일으키면 문제를 감지하고 해결할 수 있다.

---

#### 10. Third-Party Libraries and SDKs
앱이 커지고 많은 타사 라이브러리와 통합되면, 빌드 프로세스가 복잡해진다. 이러한 라이브러리들은 새로운 버전이 나오는데, 그 중 일부는 기존 코드를 올바르게 업데이트하고 다시 테스트해야 하는 중요한 변경사항일 수 있다. 

타사 라이브러리는 보안 취약점을 초대할 수 있다. 취약한 라이브러리를 사용하는 앱을 사용하는 사용자들은 자신들의 데이터가 도용될 위험을 갖거나, 보안 취약점을 해결하는 새로운 앱 버전으로 업데이트 하지 않는 경우 알 수 없는 코드가 실행될 수 있는 위험에 노출될 수 있다. 따라서 타사 라이브러리의 보안 취약점을 지속적으로 모니터링 해야 하며, 이를 위한 하나의 방법은 타사 보안 제공자를 고용하여(hire a third-party security provider) 취약점이 발생할 때 알림을 받는 것이다.

안정성과 신뢰성도 타사 라이브러리와 관련된 다른 문제다. 특정 SDK가 앱을 충돌하게 만들 수 있고, 이로 인해 해당 SDK를 포함하는 다양한 앱이 영향을 받게 되며 손실을 입는다. 이 경우 다양한 회사들이 SDK를 앱에 통합하고 바이너리를 빌드하고 모든 것을 올바르게 테스트한 후 앱 스토어에 배포했을 것이다. 이 회사들에게는 모든 것이 제어되고 있었을 것이다. 하지만, 특정 SDK에서 발생한 버그로 인해 에러가 발생하고, 이는 통합과 머지와 빌드가 완료된 시점에 테스트할 수 없었을 것이다. 그리고 한 번 충돌이 발생하면 해당 앱 개발자들은 아무런 조치를 취할 수 없으며, 바이러리는 이미 배포되어 있었고, 이것들을 제어할 수 없다. 

따라서 타사 라이브러리에 대한 특정 기능 플래그를 갖는 것이 좋은 방법이다. 이 경우 해당 라이브러리의 로딩과 실행 지점을 캡슐화하고, 해당 SDK를 개발하는 팀의 중단 변경 사항이 있을 경우 백엔드를 통해 라이브러리를 쉽게 비활성화 할 수 있다. 

타사 라이브러리 업데이트를 되돌릴 수 있게 만드는 것은 어렵거나 때로는 불가능할 수도 있다. 주요 라이브러리 업데이트는 위험할 수 있다. 위험한 변경 사항을 처리하는 합리적인 방법은 기능 플래그를 사용하여 단계적으로 적용하는 것이다. 하지만 보통 앱에 두 개의 라이브러리 버전을 포함하는것은 거의 불가능할 것이다. 심지어 두 개의 라이브러리를 포함할 수 있다 하러라도 API 변경을 처리하기 위해 수십 개의 기능 플래그 접점이 필요할 것이다. 

이는 앱에서 가장 위험한 변경 사항 중 하나다. 라이브러리 업데이트 이후 앱의 동작을 신중하게 테스트하고 충돌 보고서와 버그를 모니터링해야 한다. 주요 라이브러리 업데이트 이후에는 다른 되돌릴 수 있는 변경 사항들보다 더 많은 직원 테스트와 베타 테스트를 수행하는 것이 좋은 실천 방법이다. 

타사 라이브러리 사용으로 인해 발생할 수 있는 많은 다른 위험 사항들도 고려해야 한다. 여러 모바일 팀들은 새로운 타사 종속성을 사용하기 전에 실행 기준을 만들어 실행한다. 

- 앱 크기(App Size): 해당 종속성이 번들 크기에 얼마나 영향을 미치는가?
- 툴 업그레이드 위험(Tooling upgrade risks): 해당 종속성을 추가하면 새로운 XCode나 안드로이드 스튜디오 버전으로 업그레이드할 때 장애가 발생할 수 있나?
- 유지 관리 위험(Risk of no maintenance): 해당 종속성이 유지되지 않을 가능성이 얼마나 되는가? 예를 들면, 보안 취약점이 발견된 경우 해당 소유자가 짧은 시간 내에 이를 해결할 것으로 기대할 수 있는가?
- 타사 응답성(Third-party responsiveness): 소유자가 발생한 문제에 빠르게 응답할 수 있는가? 버그 수정을 적시에 통합하는가?

모든 타사 종속엉을 위험으로 간주하고, 그들을 추적하고 정기적으로 사용해야 하는 필요성을 재평가 하는 것은 아주 좋은 접근 방법이다. 

---

#### 11. Device And OS Fragmentation
기기 모델과 OS 단편화는 iOS와 AOS 모두에서 발생하는 문제다. 기기 단편화와 이상한 하드웨어 관련 버그는 AOS에서는 친숙한 페인 포인트였다(familiar pain points). OS 단편화는 iOS에서는 그다지 문제가 되지 않지만, AOS에서는 계속 악화되고 있다. 

새로운 OS 출시와 함께 따라오는 API 변경을 따라가는 것은 모바일 개발자들에게 집중을 요구한다. iOS와 AOS 모두 혁신을 지속하며 기능과 API가 추가, 변경 및 폐기되고 있다. `SwiftUI`나 `iOS13의 다크모드`와 같은 큰 변화, 또는 `iOS8` 및 `AOS10` 에서의 생체 인증 API와 같은 큰 변화만이 아니다. `안드로이드 오레오` 에서의 신용카드 및 채크카드와 같은 몇 가지 더 작은 API는 한 플랫폼에서만 존재하며 다른 플랫폼에서는 동등한 것이 없다. 솔직히 말하면, `WWDC`나 `Google I/O`에서 새로운 API에 대해 배우고 그것들을 앱에 추가하는 것이 재미있는 부분이다. 

앱이 오래된 OS와 기기에서 문제없이 작동하도록 보장하는 것은 큰 도전이다. 일반적으로 모든 중요한 모델에서 앱이 올바르게 작동하는지 확인하려면 내무 기기 랩을 설정하거나 타사 테스트 서비스를 사용해야 할 수 있다. 

오래된 OS 버전 지원을 어떻게 하고, 언제 중단할지 결정하는 것은 모바일 개발팀이 초기에 해야할 과정이다. 오래된 OS 버전을 지원하는 비용은 높으며, 이익은 낮을 수 있다. 비지니스가 가능한 많은 기기를 지원하려고 자연스럽게 노력할 것이다. 팀은 이 지원이 얼마나 큰지를 정량화해야한다. 오래된 버전의 수익 또는 이익이 유지 비용보다 적을 경우, 실용적인 해결책은 오래된 OS 지원을 중단하는 것이다.

특정 산업에서 오래된 OS 버전을 지원해야 하는 법적 요구사항이 있을 수 있지만, 지원해야 하는 버전이 적을수록 더 빠르게 진행할 수 있다. 특히 iOS에서는 더 빠른 OS 적용으로 많은 기업이 새로운 OS 출시 후 빠르게 두 세대 이상의 버전을 지원 중단한다.
