### PART1: Challenges due to the nature of mobile applications

앱 개발 경험이 없는 사람들은 네이티브 앱 개발이 웹 개발과 비슷할 것이라 생각하지만 그렇지 않다.

웹 혹은 백엔드와 다르게, 앱의 이진 배포(binary distribution of mobile apps), 낮은 전력 소모(low connectivity setup), 앱 푸시, 딥 링크, 인앱 결제 등 기능을 통합해야 한다.

#### 1. State Management

네이티브 개발에 있어 상태관리는 복잡하다. 모던 웹, 백엔드도 비슷하지만, 네이티브 개발에서는 앱의 `app lifeCycle events`, `화면 전환`을 신경써야 한다. 라이프 사이클과 관련한 예시로, 
앱이 일시정지 또는 백그라운드로 이동한 후, 포그라운드로 돌아오거나 중단되는 경우가 있다. (the app pausing and going to the background, the returning to the foreground or being suspened)

`이벤트`는 대부분의 앱에서 상태 변화를 일으키며, '상태 변경', '네트워크 요청', '유저 인풋' 같은 비동기 방식으로 트리거 된다. 대부분의 버그 또는 앱 크래쉬는 `이벤트`와 `앱 상태 붕괴`로 발생하며, 상태가 붕괴되는 문제는
전역(global) 또는 지역(local) 상태가 서로 알려지지 않은 여러 구성 요소에 의해 조작되는 앱의 일반적인 문제이다. 이러한 문제를 겪는 팀은 컴포넌트와 앱의 상태를 분리하고(isolate component and application state),
반응형 상태 관리(reactive state management)를 도입해야 한다.

`반응형 프로그래밍(Reactive Programming)`은 크고, 상태를 관리하기 위한 앱에서, 상태 변경을 격리시키기 위해 선호되는 프로그래밍 방식이다. 상태를 가능한한 변하지 않도록 유지하고, 모델을 상태 변화를 방출하는 불변의 객체로 저장한다.
`컴포넌트 트리 아래(down a tree of components)`방향으로 상태를 변경해 나가는 과정이 지루할 수 있지만, 지루함은 컴포넌트에서 의도하지 않은 상태 변경을 만들기 어렵게 한다.

같은 자원을 공유하는 앱과 짧은 시간에 OS Killing 앱은 모바일 개발을 위한 것과 백엔드 또는 웹 개발을 위한 개발에 두 가지 큰 차이가 있다. OS는 'CPU', '메모리', '에너지 소비'를 모니터링 한다. 만약 특정 앱이 많은 리소스를 활용하고 있다고 OS가 판단한다면, 약간의 경고(little warning)로 종료될 수 있다. **이것은 앱의 상태 변경에 대응하고, 상태를 저정하고, 앱을 실행 중인 곳으로 복원 하는 앱 개발자의 책임이다.** iOS 에서 이것을 상태를 관리하고, 그 사이의 전환을 처리하는 것을 의미한다(On iOS, this means handling app states and transitions between them)

권한, 블루투스와 같은 전역적인 앱 상태는 도전 과제를 제시한다. 하나의 전역 상태가 바뀔 때마다 네트워크 연결이 끊어지면 앱의 다른 부분은 다르게 반응해야할 수도 있다.
전역 상태와 함께 특정 컴포넌트가 상태 변화를 듣도록 결정되어야 한다. 하나의 스팩트럼의 앱의 화면 또는 컴포넌트는 전역 상택의 변화를 들을 수 있다. 이로 인해 많은 코드 중복이 발생하지만, 컴포넌트는 전역 상태를 핸들링 한다(components handling all of the global state concerns).
결과적으로 컴포넌트는 특정 글로벌 상태 변화를 듣고 이를 앱의 특정 부분으로 전달할 수 있다. 이것은 덜 복잡한 코드의 결과가 되지만, 전역 상태 관리와 그것을 알고 있는 컴포넌트 사이 심한 결합(tight coupling)을 가지고 있다. 

딥링크, 또는 내부 네비게이션(internal shortcut navitaion points) 또한 앱 상태 관리에 복잡성을 더한다. 딥링크를 예로 들면, 딥링크가 활성화 된 후 앱의 상태를 설정해야 할 수도 있다. 


#### 2. Mistakes Are Hard To Revert

모바일 앱은 바이너리 파일로 구성되어 배포된다. 클라이언트 파트 버그가 있는 버전으로 유저가 업데이트를 진행하면, 유저는 새로운 버전이 업데이트되기까지 해당 버전에 갇히게 된다. 

애플과 구글 모두 앱으로 실행 가능한 코드를 전송하는 것에 엄격한 제한을 두고 있다. 애플은 앱스토어 가이드 라인에서 기능을 변경하는 코드를 실행시키는 것을 금지하며, 구글은 프로그램 정책에 따라 관련 없는 실행 가능한 코드를 악성 코드로 간주한다.
그러나, 잘못된 버그를 되돌리는 기능은 양쪽 스토어의 정책에 포함되어야 한다. 또한 애플을 자바스크립트같은 네이티브 코드가 아닌 코드도 허용하고 있으며, `코드 푸시(CodePush)` 와 같은 솔루션이 인기있는 이유다.
코드 푸시는 `React Native`, `Cordova` 앱이 즉시 업데이트 될 수 있도록 허용한다. 우버에서 우리는 자체 솔루션을 구축했다. 

- 새로운 앱을 배포하는데까지는 며칠이 걸린다. 애플의 경우 모든 앱에 대해 수동 검토가 이뤄지며, 이는 24~48 시간 정도가 걸리며, 모든 앱은 리젝 당할 수 있다. 2020.06을 기준으로 애플은 가이드라인 위반으로 법적 문제를 제외하고, 버그 수정이 더 이상 지연되지 않는 방침을 변경했다. 
- 사용자들은 스토어에 새로운 버전이 배포된 이후, 실제 신규 버전을 배포 받기 까지 며칠이 걸리며, 이는 자동 업데이트가 켜져 있는 사용자도 마찬가지다. 
- 모든 사용자가 이 업데이트된 버전을 받을 것이라고 가정할 수 없다. 몇몇 유저는 자동 업데이트를 비활성화 했을 수도 있으며, 업데이트를 하더라도 몇몇개의 버전을 건너뛸 수 있다. 

```
it was the most terrifying thing to take 10,000 diffs, package it into effectively a bullet,
fire that bullet at the horizon and that bullet once it leaves the barrel, it's gone.
i cannot get it back, and it flies flat and true with no friction and to gravity till the heat death of the universe.
it's gone. i can't fix it
```

이는 앱의 모든 이전 버전이 무기한으로 지원되어야 함을 의미하며, 지원하도록 만들어야 한다. 유일한 예외는 자체 제작 컨토롤을 도입하고, 과거 버전을 지원하기 위해 강제 업데이트 메커니즘을 구축하는 경우다. 
안드로이드의 경우 `Play Core`라이브러리에서 앱 내 업데이트를 지원하지만, iOS는 비슷한 내장 지원 기능을 가지고 있지 않다.

수백만명의 사용자가 있는 앱이 있다고 가정하면, 이전 버전에서 발생하는 버그나 회귀를 최소화하기 위해 어떤 조치를 취할 수 있을까?

- 모든 레벨의 테스트를 진행하라(Do Thorough testing at all levels). 자동 테스트 매뉴얼 테스트, 그리고 쉬운 피드백을 받을 수 있는 베타 테스트까지. 많은 회사의 일반적인 접근 방식은 일주일 동안 사용해 볼 수 있도록
  베타 앱을 출시하고 모든 문제에 대한 피드백을 수집하는 것이다.
- 기능 플래그 시스템을 갖추고 있으므로, 버그를 되돌릴 수 있다. 여전히 기능 플래그는 더 많은 문제점을 더한다.
- 예상대로 작동하도록 모니터링과 함께 점진적인 규칙울 고려해라.
- 강제 업데이트는 강력한 솔루션이지만, 이를 실행하기 위해서는 고려해야 하며, 이 과정에서 몇몇 고객들이 떠날 수도 있다.




