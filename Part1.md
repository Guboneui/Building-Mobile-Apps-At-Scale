### PART1: Challenges due to the nature of mobile applications

앱 개발 경험이 없는 사람들은 네이티브 앱 개발이 웹 개발과 비슷할 것이라 생각하지만 그렇지 않다.

웹 혹은 백엔드와 다르게, 앱의 이진 배포(binary distribution of mobile apps), 낮은 전력 소모(low connectivity setup), 앱 푸시, 딥 링크, 인앱 결제 등 기능을 통합해야 한다.

---

#### 1. State Management

네이티브 개발에 있어 상태관리는 복잡하다. 모던 웹, 백엔드도 비슷하지만, 네이티브 개발에서는 앱의 `app lifeCycle events`, `화면 전환`을 신경써야 한다. 라이프 사이클과 관련한 예시로, 
앱이 일시정지 또는 백그라운드로 이동한 후, 포그라운드로 돌아오거나 중단되는 경우가 있다. (the app pausing and going to the background, the returning to the foreground or being suspened)

`이벤트`는 대부분의 앱에서 상태 변화를 일으키며, '상태 변경', '네트워크 요청', '유저 인풋' 같은 비동기 방식으로 트리거 된다. 대부분의 버그 또는 앱 크래쉬는 `이벤트`와 `앱 상태 붕괴`로 발생하며, 상태가 붕괴되는 문제는
전역(global) 또는 지역(local) 상태가 서로 알려지지 않은 여러 구성 요소에 의해 조작되는 앱의 일반적인 문제이다. 이러한 문제를 겪는 팀은 컴포넌트와 앱의 상태를 분리하고(isolate component and application state),
반응형 상태 관리(reactive state management)를 도입해야 한다.

`반응형 프로그래밍(Reactive Programming)`은 크고, 상태를 관리하기 위한 앱에서, 상태 변경을 격리시키기 위해 선호되는 프로그래밍 방식이다. 상태를 가능한한 변하지 않도록 유지하고, 모델을 상태 변화를 방출하는 불변의 객체로 저장한다.
`컴포넌트 트리 아래(down a tree of components)`방향으로 상태를 변경해 나가는 과정이 지루할 수 있지만, 지루함은 컴포넌트에서 의도하지 않은 상태 변경을 만들기 어렵게 한다.

같은 자원을 공유하는 앱과 짧은 시간에 OS Killing 앱은 모바일 개발을 위한 것과 백엔드 또는 웹 개발을 위한 개발에 두 가지 큰 차이가 있다. OS는 'CPU', '메모리', '에너지 소비'를 모니터링 한다. 만약 특정 앱이 많은 리소스를 활용하고 있다고 OS가 판단한다면, 약간의 경고(little warning)로 종료될 수 있다. **이것은 앱의 상태 변경에 대응하고, 상태를 저정하고, 앱을 실행 중인 곳으로 복원 하는 앱 개발자의 책임이다.** iOS 에서 이것을 상태를 관리하고, 그 사이의 전환을 처리하는 것을 의미한다(On iOS, this means handling app states and transitions between them)

권한, 블루투스와 같은 전역적인 앱 상태는 도전 과제를 제시한다. 하나의 전역 상태가 바뀔 때마다 네트워크 연결이 끊어지면 앱의 다른 부분은 다르게 반응해야할 수도 있다.
전역 상태와 함께 특정 컴포넌트가 상태 변화를 듣도록 결정되어야 한다. 하나의 스팩트럼의 앱의 화면 또는 컴포넌트는 전역 상택의 변화를 들을 수 있다. 이로 인해 많은 코드 중복이 발생하지만, 컴포넌트는 전역 상태를 핸들링 한다(components handling all of the global state concerns).
결과적으로 컴포넌트는 특정 글로벌 상태 변화를 듣고 이를 앱의 특정 부분으로 전달할 수 있다. 이것은 덜 복잡한 코드의 결과가 되지만, 전역 상태 관리와 그것을 알고 있는 컴포넌트 사이 심한 결합(tight coupling)을 가지고 있다. 

딥링크, 또는 내부 네비게이션(internal shortcut navitaion points) 또한 앱 상태 관리에 복잡성을 더한다. 딥링크를 예로 들면, 딥링크가 활성화 된 후 앱의 상태를 설정해야 할 수도 있다. 

---

#### 2. Mistakes Are Hard To Revert

모바일 앱은 바이너리 파일로 구성되어 배포된다. 클라이언트 파트 버그가 있는 버전으로 유저가 업데이트를 진행하면, 유저는 새로운 버전이 업데이트되기까지 해당 버전에 갇히게 된다. 

애플과 구글 모두 앱으로 실행 가능한 코드를 전송하는 것에 엄격한 제한을 두고 있다. 애플은 앱스토어 가이드 라인에서 기능을 변경하는 코드를 실행시키는 것을 금지하며, 구글은 프로그램 정책에 따라 관련 없는 실행 가능한 코드를 악성 코드로 간주한다.
그러나, 잘못된 버그를 되돌리는 기능은 양쪽 스토어의 정책에 포함되어야 한다. 또한 애플을 자바스크립트같은 네이티브 코드가 아닌 코드도 허용하고 있으며, `코드 푸시(CodePush)` 와 같은 솔루션이 인기있는 이유다.
코드 푸시는 `React Native`, `Cordova` 앱이 즉시 업데이트 될 수 있도록 허용한다. 우버에서 우리는 자체 솔루션을 구축했다. 

- 새로운 앱을 배포하는데까지는 며칠이 걸린다. 애플의 경우 모든 앱에 대해 수동 검토가 이뤄지며, 이는 24~48 시간 정도가 걸리며, 모든 앱은 리젝 당할 수 있다. 2020.06을 기준으로 애플은 가이드라인 위반으로 법적 문제를 제외하고, 버그 수정이 더 이상 지연되지 않는 방침을 변경했다. 
- 사용자들은 스토어에 새로운 버전이 배포된 이후, 실제 신규 버전을 배포 받기 까지 며칠이 걸리며, 이는 자동 업데이트가 켜져 있는 사용자도 마찬가지다. 
- 모든 사용자가 이 업데이트된 버전을 받을 것이라고 가정할 수 없다. 몇몇 유저는 자동 업데이트를 비활성화 했을 수도 있으며, 업데이트를 하더라도 몇몇개의 버전을 건너뛸 수 있다. 

```
it was the most terrifying thing to take 10,000 diffs, package it into effectively a bullet,
fire that bullet at the horizon and that bullet once it leaves the barrel, it's gone.
i cannot get it back, and it flies flat and true with no friction and to gravity till the heat death of the universe.
it's gone. i can't fix it
```

이는 앱의 모든 이전 버전이 무기한으로 지원되어야 함을 의미하며, 지원하도록 만들어야 한다. 유일한 예외는 자체 제작 컨토롤을 도입하고, 과거 버전을 지원하기 위해 강제 업데이트 메커니즘을 구축하는 경우다. 
안드로이드의 경우 `Play Core`라이브러리에서 앱 내 업데이트를 지원하지만, iOS는 비슷한 내장 지원 기능을 가지고 있지 않다.

수백만명의 사용자가 있는 앱이 있다고 가정하면, 이전 버전에서 발생하는 버그나 회귀를 최소화하기 위해 어떤 조치를 취할 수 있을까?

- 모든 레벨의 테스트를 진행하라(Do Thorough testing at all levels). 자동 테스트 매뉴얼 테스트, 그리고 쉬운 피드백을 받을 수 있는 베타 테스트까지. 많은 회사의 일반적인 접근 방식은 일주일 동안 사용해 볼 수 있도록
  베타 앱을 출시하고 모든 문제에 대한 피드백을 수집하는 것이다.
- 기능 플래그 시스템을 갖추고 있으므로, 버그를 되돌릴 수 있다. 여전히 기능 플래그는 더 많은 문제점을 더한다.
- 예상대로 작동하도록 모니터링과 함께 점진적인 규칙울 고려해라.
- 강제 업데이트는 강력한 솔루션이지만, 이를 실행하기 위해서는 고려해야 하며, 이 과정에서 몇몇 고객들이 떠날 수도 있다.

---

#### 3. The Long Tail Of Old App Versions

오래된 앱 버전은 최대 몇 년 동안 유지되며, 엄격한 강제 업데이트 정책을 시행하는 몇몇 팀인 경우에만 짧게 유지될 것이다. 

대부분의 사용자는 며칠 안에 새로운 앱 버전으로 업데이트 하지만, 여러 버전이 뒤쳐진 사용자가 있을 것이다. 일부 사용자는 의도적으로 자동 업데이트를 비활성화 하지만, 오래된 기기 또는 OS로 인해 사용이 불가능해진다.
또한 오래된 앱 버전은 보수가 적은 많은 노력이기 때문에 정기적으로 테스트 되지 않는다. 

깨지지 않는 백엔드(서버)의 변경 조차도 특정 응답의 내용을 변경하는 것 처럼 오래된 버전을 깨뜨릴 수 있다. 이러한 크래쉬를 피하기 위한 몇 가지 방법이 있다. 

- 전용 도구를 사용해 네트워크 응답 처리 및 파싱을 견고하게 구축해야한다. `GraphQL`과 같이 클라이언트와 백엔드 간에 생성된 더 강력하고 형식화된 것을 선호한다. 이는 수동으로 유효성을 검사해야하는 `REST` 인터페이스보다 훨씬 더 나은 방법으로, 누군가 모바일에서 파싱 로직을 업데이트를 잊어버린 경우 `REST` 인터페이스에서 예기지 않은 오류가 발생할 수 있다.
- 백엔드 변경을 깨기 위해 미리 계획해야 한다. 백엔드 팀과 열린 커뮤티케이션을 가져라. 오래된 앱을 테스트 할 수 있는 방법이 있다. 강제 업그레이드가 모든 현재 앱 사용자를 이전 엔드포인트에서 옮길 때까지 새로운 엔드포인트를 구축하고 오래된 엔트포인트를 폐기하지 않는 것을 고려해야 한다.
- 벡엔드 엔드포인트의 버전을 관리할 때, 호환성에 영향을 미치는 변경사항이 있을 경우 기존 엔드포인트를 폐기하고 새로운 버전의 엔드포인트를 만드는 것이 일반적이다. 
- 백엔드 엔드포인트를 폐기하는 경우, 트래픽을 모니터링하고 필요한 경우 요청을 효율적으로 전달할 수 있는 마이그레이션 계획이 필요하다. 엔트포인트를 폐기하는 것은 신중하게 진행해야하며, 사용자의 요청을 확인하는 방법을 구체적으로 계획해야 한다.
- 앱 버전 단위로 사용 상태를 추적해야 한다. 세 개 이상의 이전 버전을 사용중인 사용자의 비율이 얼마나 되는지 확인해야 하며, 해당 데이터를 바탕으로 구형 버전에서 어느 정도의 노력을 기울여야 하는지 결정하는 것이 용이하다.
- 클라이언트 사이드를 모니터링 하고 알림을 둬야 한다. 이러한 경고는 모바일 담당자 또는 일반 담당자에게 전달될 수 있다.
- 적어도 주요 업데이트에 대해서는 업그레이드 테스팅을 고려해봐야한다. 업그레이드 테스팅은 비용이 많이 들고, 자동화하기 어렵다. 또한 시험해야 할 여러 가지 조합이 있을 수 있다. 이 같은 이유로 테스트 비용이 많이 들어 거의 수행하지 않는 경우가 많다.

---

#### 4. DeepLinks
딥링크는 앱의 특정 부분을 열기 위해 제공되는 웹 또는 디바이스 링크이며, 이는 모바일 플랫폼에서 까다로운 문제가 된다. iOS, AOS 둘다 이를 위한 API를 제공하지만, 이에 대한 네이티브 프레임워크나 추천 방법은 업다. 한 기사에서는 "딩링크는 보아일에서 해결해야 할 가장 과소평가된 문제 중 하나 (Deep Linking is one of the most underestimated problems to solve on mobile" 이라고 언급했다. 

다음은 딥링크를 어렵게 만드는 몇 가지 이유가 있다. 
- 하위 호환성: 이전 버전에서도 딥링크가 정상적으로 동작하도록 해야 한다.
- 현재 상태를 갖고 있는 앱에서 딥링크로 링크를 열 때. 예를 들어 앱에서 디테일 페이지에 위치하고, 이메일 앱에서 다른 디테일 페이지를 가리키는 딥링크를 탭하는 경우. 현재 상태를 유지하면서 새로운 디테일 페이지가 네비게이션 스택에 추가 또는 상태를 초기화 해야 될까? 대부분의 솔루션은 상태를 초기화 하는 방법이다. 그러나 문제가 발생하지 않아야 할 플로우도 있기 때문에 신중하게 계획해야 한다.
- iOS와 AOS 간 딥링크 구현 방법이 다르기 때문에. `Firebase Dynamic Links` 또는 `Branch`와 같은 라이브러리를 사용하면 하나의 인터페이스로 작업을 추상화 할 수 있다.
- 사전 계획이 부족한 경우. 딥링크는 여러 버전이 출시된 후에 고려되는 경우가 많다. 웹과 달리 딥링크를 추가하는 것은 간단하지 않으므로, 딥링크 전략을 후반부에 추가하는 것은 엔지니어적 도전이다. 딥링크는 상태 관리 및 탐색 아키텍처와 관련이 있다.

딥링크의 가장 큰 문제는 iOS나 AOS에서 설계하고 테스트하는 방법에 대해 명확한 접근 방식을 제공하지 않는다는 것이다. 딥링크의 수가 증가하면, 이를 계속 동작시키는 데 필요한 노력과 복잡성이 급증한다. 합리적이면서 확장 가능한 딥링크 구현을 구축하기 위해서는 미리 잘 계획하는 것이 필요하다.

---

#### 5. Push And Background Notifications
앱 푸시 알림은 알림, 커뮤니케이션, 마케팅 툴로 빈번히 사용된다. 사업은 푸시를 사용하는 것을 좋아하며, 앱 개발자로서 이 방법을 지원하도록 요청받을 가능성이 높다. 하지만 푸시 알림을 구현하는데 문제점이 있다. 

푸시 알림을 세팅하는 것은 복잡하다. iOS, AOS 둘다 너의 앱은 토큰을 가져와 백엔드에 저장해야 한다. 푸시 알림을 작동시키기 위해 많은 단계가 필요하다. 

푸시 알림 요청은 백엔드에서 진행되어야 하며, 백엔드 팀과 함꼐 어떤 타입의 알림을 보낼것인지 결정해야 한다. 백엔드 팀은 모바입 푸시 알림 인프라 및 기능을 익혀 최대한 활용할 수 있도록 노력해야 한다. 

이메일 및 문자와 함께 푸시 알림을 사용하는 것은 매우 유명한 마케팅 전략이다. 이론적으로 이런 용도는 iOS 앱 가이드라인에 위반될 가능성이 있지만, 대부분의 앱에서 사용된다. 푸시 알림을 직접 구현하는 대신, 비슷하게 타사 서비스를 사용할 수도 있다. 

푸시 알림은 문제가 많으며 구현하는 것 뿐만 아니라 추가적인 문제를 야기할 수 있다. 

- 어떤 액션이 트리거 되어야 하는지 구현하는데 딥링크와 비슷한 문제가 있다. 푸시 알림은 딥링크와 내부적으로 유사하며, 백워드 호환성과 상태 문제, 추후 상황에 대한 계획등이 모두 적용된다. (Thinking about backwoard compatibility, state problems, and planning ahead all apply to push notifications as well)
- 상요자가 수신을 거부할 수 있다. iOS와 AOS 에서는 사용자가 수신 거부 또는 동의한 경우를 감지하는 방법과 한계가 있다. iOS의 경우 사용자가 알림을 거부했더라도, `silent background Notification`을 보낼 수 있다. 사용자가 푸시 알림을 수신할 수 없을 수도 있으므로, 푸시 알림은 일반적으로 어플리케이션에서 중요하지 않다고 여겨지는 부분이다.
- 푸시 알림이 성공적으로 전달됨을 보장되지 않는다. 특히 대량으로 보낼 때 푸시 알림을 제한할 수 있다. 이러한 제한 규칙은 불분명하다. 하지만 디바이스 연결 문제와 OS가 최근에 활동하지 않은 앱에 대해 알림을 제한할 수 있으므로 알림을 수신하지 못할 수도 있다.

푸시 알림을 테스트 하는 것 또한 하나의 도전이다. 시뮬레이터를 통해 수동으로 테스트를 해볼 수는 있다. 하지만 자동화된 테스트에서 이를 테스트 하기 위해서는 UI에 대한 end-to-end 테스트를 진행해야 하며, 이는 비용이 많이 든다. 

iOS에서 백그라운드 알림은 사용자에게 노출되지 않으며 직접 앱에 전달되는 푸시 메세지의 특수한 유형이다. 이러한 유형은 백엔드 업데이트를 클라이언트에게 동기화하는 데 유용하다. 이러한 종류의 알림은 동기화된 백엔드 알림 사용시 유용하다(These kinds of notifications are useful to sync backend updates to the client). 이러한 알림을 AOS에서는 `Data Message`라고 부르며, iOS에서는 `background Notificiation`이라고 부른다. 

백그라운드 알림은 실시간 및 벌티 디바이스 시나리오에 유용하다. 앱이 이 영역에 있으면 iOS와 AOS 용 크로스 플랫폼 솔루션을 구현하고, 모바일 앱이 서버를 폴링하는 대신 서버가 백그라운드 푸시 알림을 통해 데이터를 클라이언트에 보내도록 할 수 있다. 

백그라운드 알림은 아키텍처 및 비즈니스 로직을 간단하게 만들 수 있지만, 알림 전송 문제, 메세지 순서 문제, 오프라인 시나리오에 대한 로컬 데이터 캐싱과 결합해야 한다.

---

#### 6. App Crashes
앱 충돌은 모바일 앱에서 가장 눈에 띄는 버그 중 하나이며, 비즈니스에 큰 영향을 미친다. 유저는 핵심 플로우를 완료하지 못하고, 앱 사용을 중단하거나, 좋지않은 리뷰를 남기고 떠날수도 있다.

충돌은 모바일 전용 문제가 아니다. 백엔드 파트에서 주요한 포커스로, 잡을 수 없는 예외나 500 상태 코드를 모니터링 하는 것이다. 웹은 샌드박스 충돌 내의 단일 스레드 실행은 모바일 앱보다 드물다. 

충돌의 첫 번째 규칙은 충돌이 언제 발생하는지 추적하고, 충분한 디버그 정보를 가지고 있어야 한다. 충돌을 추적하며 세션의 몇 퍼센트가 충돌하는지 보고하고 이 숫자를 최대한 줄이고 싶어할 것이다. 

충돌 보고를 직접 구현하거나, 별도의 솔루션 제품을 사용할 수 있다. 대부분의 팀은 네이티브 앱을 위해 `Crashlytics` 또는 `Bugsnag` 같은 솔루션 중 하나를 선택한다. 

iOS에서 충돌 보고서(Crash Reports)는 로그를 매핑하는 데 사용할 수 있는 모든 충돌과 함께 장치에 생성된다. 애플은 개발자가 테스트플라이트나 앱스토어를 통해 이 정보를 공유하기로 선택한 사용자로부터 충돌 로그를 수집할 수 있는 방법을 제공한다. 이 접근 방식은 더 작은 앱에 충분히 잘 작동한다. 

안드로이드에서 구글 플레이스토어는 또한 개발자들이 구글 플레이 손솔에서 안드로이드 바이탈을 통해 충돌 스택 추적을 볼 수 있게 해주며, 애플과 마찬가지로 개발자에게 버그 보고서를 보내기로 선택한 사용자만 이 포털에 로그를 남길 수 있다. 

타사 라이브러리(Third Party) 또는 직접 만든(Custom-built) 충돌 보고 솔루션은 앱스토어와 구글 플레이스토어가 제공하는 것 외에도 몇 가지 이점을 얻을 수 있으며 다음과 같다.

- 더 많은 정보: 충돌로 이어질 수 있는 더 많은 정보를 제공받을 수 있다.
- 풍부한 보고: 타사 라이브러리는 일반적으로 보고서 그룹화 및 iOS 및 안드로이드 충돌률 비교를 제공한다.
- 모니터링 및 경고: 새로운 유형의 충돌이 나타나거나 특정 충돌이 급증할 때 알림을 받도록 설정할 수 있다.
- 개발 스택과의 통합: 새로운 충돌과 관련해 ticketing System(지라?), 또는 풀 리퀘스트로 참고할 수 있다.

타사 라이브러리의 단점은 충돌 및 치명적이지 않은 오류에 대한 정보만 수집할 뿐, 앱이 응답하지 않거나 메모리 문제같은 것은 포함하지 않는다. 많은 앱을 가진 조직은 보고가 충분히 풍부하지 않다는 것을 알 수 있으며, 많은 앱의 건강 상태를 비교하기 위해 자체 시스템을 만드록 싶을 수도 있다. 또한 사내 프로젝트 관리 및 코딩 툴과 저 잘 통합하는 것도 커스텀 할 이유가 된다. 

충돌의 재현성과 디버깅 가능성은 백엔드나 웹보다 모바일에 더 많은 영향을 미치는 문제다. 특히 안드로이드 세계에서 사용자는 다양한 앱 버전으로 다양한 OS 버전을 실행하는 다양한 장치를 가지고 있다. 시뮬레이터나 다른 장치에서 충돌을 재현할 수 있다면, 문제를 해결하지 않을 변겸의 여지가 없다. 하지만 특정 기기에서만 충돌이 난다면 어떻게 해야할까?

임계값을 정의하기 위해 우선 순위 지정 프레임워크를 마련하여 충돌을 조사하고 수정하는데 시간을 할애해야한다. 이 임계값은 충돌의 성격(nature of the crash), 고객 평생 가치 및 기타 비즈니스 고려 사항에 따라 달라질 것이다. 

수정의 장점과 비교하여 조사 및 수정 비용과 수익 창출 기능 구축과 같은 다른 것에 시간을 소비하는 엔지니어의 기회 비용을 비교해야 한다. 

앱 안정성은 퇴행하지 않도록 하기 위해 결국 측정하고 싶은 지표다. 앱이 결코 충돌이 없어야겠지만, 1,000개의 세션 중 1개 미만이 영향을 받는다는 것을 의미하는 안정성 수준으로 충돌을 줄일 수 있다면, 당신은 올바른 길을 가고 있는 것이다. 총 사용자 세션을 기반으로 앱 안정성 점수를 게샇나고, 목표를 달성할 때까지 충돌을 줄이는 데 시간을 투자하는 것을 목표로 해야한다. 

`Bugsnag`은 평균 앱 안정성 점수의 지표를 발표했다. 
- 1~10명의 엔지니어가 만든 경우 99.4%
- 11~50명의 엔지니어가 만든 경우 99.6%
- 51~100명의 엔지니어가 만든 경우 99.89%
- 100+명의 엔지니어가 만든 경우 99.79%

만약 앱 안정성이 99.99% 이상인 경우 해당 앱은 경쟁에서 훨씬 앞서있으며, 세계적 수준의 신뢰성으로 간주될 것이다. 

---

#### 7. Offline Support
오프라인 지원은 풍부한 웹 어플리케이션 기능이 되고 있지만, 네이티브 모바일 앱에서는 핵심기능이다. 사람들은 신호가 약해지거나 연결이 끊어지더라도 앱을 계속 사용할 수 있기를 기대한다. 

적절한 오프라인 모드 지원은 앱에 많은 복잡성과 예상치 못한 예외 상황을 추가한다.

- 휴대폰이 오프라인 상태인지 신뢰성 있게 감지하는 것은 중요하다. 운영체제는 사용자가 온라인 상태임을 보고할 수 있지만, 이는 항상 사실이 되지 않을 수 있다. 휴대폰이 `captive portals`을 사용하는 Wi-Fi 지점에 연결되면 데이터가 전송되지 않을 수도 있으며, 이과 같은 예외적인 상황에서 앱은 몇 개의 `always online` 핑을 도메인에 보내 확인할 수 있다.
- 연결 속도와 지연 시간을 감지하고 필요한 경우 앱의 동작은 변경하는 것은 중요하다. 스트리밍 앱은 사용 가능한 대역폭에 맞게 스트림을 최적화한다. 다른 앱은 앱에 방해가 되는 연결 불안정성에 대해 사용자에게 경고할 수 있으며, 이러한 예외 상황을 처리하는 방식에 대해 미리 계획을 세워야 한다.
- 기기가 오프라인 상태일 떄 로컬 상태를 유지하고, 다시 연결이 되면 동기화하는 것은 중요하다. 사용자가 온라인 또는 오프라인인 여러 기기에서 앱을 사용하는 경우 `경합 조건(Race Condition)`을 고려해야 한다. 로컬에 저장된 데이터를 수정하는 앱 업데이트에 대해서는 기존 데이터를 새로운 형식으로 마이그레이션하는 것에 대해 추가적인 주의가 필요하다.

어떤 기능이 오프라인에서 작동해야 하고 어떤 기능이 그렇지 않아야 할 지 결정하는 것은 중요한 단계다. 이러한 간단한 단계를 놓치는 경우 오프라인 기능의 계획이 어려워지고, 범위 확장이 발생할 수 있다. 이 경우 '앱의 주요 부분부터 시작하고 이 범위를 천천히 확장하는 것이 좋다(starting with the key parts of the application and expanding this scope slowly)'. 중요한 오프라인 모드가 예상대로 작동하는지 실제 사용자의 피드백을 받아야 한다. 이러한 접근 방식을 앱의 다른 부분에 활용할 수 있는지 살펴봐야 한다. 

오프라인 예외 상황을 처리하는 방법을 결정해야 한다. 휴대폰은 여전히 온라인 상태이지만 데이터 연결이 지나치게 느린 경우에는 어떻게 처리할지 결정해야 한다. 견고한 채결책은 이를 오프라인으로 간주하고 사용자에게 이 사실을 알릴 수 있다. 그렇다면 시간 초과 다시 시도해 처리할 것인가?

재시도는 까다로운 엣지 케이스가 될 수 있다. 일정 시간동안 응답이 없는 연결이 있는 경우 다른 요청을 재시도 한다고 가정해보자. 첫 번째 요청이 반환되고 나서 두 번째 요청도 반환된다면, 데이터 경합 조건이나 데이터 문제가 발생할 수 있다. 

동기화는 기기와 백엔드 데이터 간의 문제이며 여러 기기로 인해 복잡성이 증가하는 일반적이고 동시에 도전적인 문제다. 여러 개의 동시 오프라인 편집을 처리하고 연결이 중간에 끊어지는 상황을 견딜 수 있는 충분히 강력한 충돌 해결 프로토콜을 선택해야 한다.

```
- 재시도 전에 네트워크가 정말로 끊어진 상태인지 어떻게 확신할 수 있을까요?
- 사용자가 무작정 재시도하고 여러 개의 병렬 요청을 생성하는 상황을 어떻게 처리할까요?
- 이전 요청이 완료되지 않은 상태에서 같은 요청이 가능한가요?
- 오프라인 모드로 전환될 때, 앱은 언제 네트워크가 신뢰할만한 상태로 복구되었다고 알 수 있을까요?
- 앱은 백엔드 서비스가 응답하지 않는 것인지 아니면 네트워크가 느린 것인지 어떻게 구분할 수 있을까요?
- 자원 효율성에 대해서는 ETag 또는 if-match 헤더를 활용한 HTTP 조건부 요청과 재시도를 고려해야 할까요?
```
와 같은 물음이 생길 수 있다. 

약한 연결 상태에서는 네트워크 요청이 때떄로 시간 초과가 될 수 있다. 합리적인 재시도 전략이나 오프라인 모드로 전환하는 것이 도움이 될 수 있지만, 이때 고려해야 할 다양한 트레이드 오프가 있다. 

이전에 이야기 했던, `RxSwift` `애플의 combine`, `RxJava`, `코틀린의 코루틴`을 사용하면 네트워크 연결을 처리할 떄 비교적 간단하게 해결할 수 있다.

재시도 해서는 안되는 요청은 별도의 문제를 가지고 있다. 예를 들어 결제 요청이 진행 중인 경우, 재시도 하고 싶지 않을 수 있다. 그러나 해당 요청이 실패로 반환되면 어떻게 될까? 이 경우 이후에 재시도 하는 것이 안전하다고 생각할 수 있다. 하지만 요청이 시간 초과되었지만 서버에서 결제를 수행했다면 사용자에게 중복으로 요금이 청구될 수 있다. 

백엔드 엔드포인트의 소비자로서, 모든 엔드포인트에 대한 재시도를 안전하기 진행하기 위해 `반복해도 동일한 결과`가 나올 수 있도록 해야한다. 이러한 엔드포인트를 사용하기 위해서는 특정 키를 얻고 전송해야 하며, 추가적인 상태를 추적해야 한다. 또한 앱이 충돌하고 다시 시작되는 등의 예외 상황에 대해 걱정해야 하며, 특정 키가 영구적으로 저장되지 않을 수 있는 문제도 고려해야 한다. 안전한 재시도를 구현하는 것은 팀에게 많은 추가 작업을 요구하며 이를 위해 백엔드 팀과 긴밀히 협력하여 사용 사례를 매핑하고 설계해야 한다.

상태 관리와 마찬가지로 유지 가능한 오프라인 모드와 약한 연결 지원의 핵심은 간결함이다. 변경할 수 없는 상태, 직관적인 동기화 전략, 그리고 느린 연결을 처리하기 위한 간단한 전략을 사용해야 한다. iOS의 `Network Link Conditioner` 또는 안드로이드 에뮬레이터의 `networkSpeed` 기능과 같은 적절한 도구를 사용하여 충분히 테스트 할 수 있다. 

