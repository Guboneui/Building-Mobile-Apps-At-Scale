### PART2: Challenges Due To APP Complexity

앱의 크기가 커짐에 따라, 상황이 흥비로워진다. 계속해서 새로운 기능을 추가하면서 기존 기능도 조정해야한다. 즉, 화면을 플로우 차트에 출력한다면, 몇 개의 화면이 벽 전체를 덮을 정도로 복잡해진다. 

대규모이고 복잡한 앱을 다룰 때 추가적인 도전에 직면할 수 있다. 점점 복잡해지는 네비게이션 패턴을 어떻게 다루어야 할까? 결정적이지 않은 이벤트 조합은 어떻게 다뤄야 할까? 여러 언어로 번역하는 것은 어떻게 해야 하며, 자동화된 테스트와 수동 테스트를 어떻게 확장해야 할까?

---

#### 13. Navigation Architecture Within Large Apps

모바일 앱 내에서 `네비게이션(Navigation)`은 딥링크와 마찬가지로 과소평가된 문제 영역이다. 앱이 작을 때는 그에 대해 크게 주의하지 않지만, 앱이 성장함에 따라 화면과 전환의 수가 증가하면서 탐색 구조가 길들여야 할 야수(beast)가 되었음을 깨닫게 된다. 

iOS와 안드로이드 모두 기본적인 네비게이션 개념을 제공하지만, 실제 네비게이션 아키텍처를 정의하는 작업은 개발자에게 맡겨진다. 결과적으로 네비게이션을 위해 흔히 휠을 다시 발명하게 된다(we tend to reinvent the wheel on navigation). 이는 대부분 iOS나 안드로이드가 단순한 앱을 넘어서 잘 확장되지 않는 네비게이션 접근 방법을 제공하지 않기 때문에 필요한 일이다. 

앱 상태를 잘 분리한 명확한 앱 네비게이션 전략을 가지는 것은 어느 정도 크기의 앱에 대해서도 중요하다. 화면과 구성 요소 사이에서 어떤 탐색이 일어나는 걸까?. 탭과 제스처 사이에서 어떤 애니메이션이 트리거되며, 네이게이션은 앱 상태와 독립적일까?

많은 팀은 코드를 작성하는 도중 어려움을 겪게 되면, 일관되지 않은 네비게이션 솔루션을 구축해, 사용자가 예상치 못한 상태에 빠졌을 때 버그가 발생하는 것을 발견할 수 있다. 

일관되지 않은 네입게이션은, '팝업', '토스트', '모달', 또는 화면을 일관성 없이 사용하는 앱과 같이 눈에 띌 수 있다. 서로 다른 화면 사이에서 다른 애니메이션이 사용되는 것을 의미할 수도 있다. 이로 인해 앱의 네비게이션 작동에 대한 코드 중복이 많아진다. 

비동기 네비게이션 작동은 몇몇 개발자가 미리 처리하는 것을 고려하지 않는 일반적인 문제다. 여기서 말하는 비동기 네비게이션은 네비게이션 동작이 계속되기 전에 무언가가 끝나야 하는 경우를 의미한다. 앱에 로그인하거나 양식을 제출하는 것이 이에 해당한다. 사용자가 이 단계에서 네비게이션을 시도하면 어떻게 될까? 이러한 시나이로를 계획하고 테스트 하지 않으면 앱이 이상한 상태에 빠질 수 있다. `RIBs`를 사용하면 워크 플로우가 이 문제에 우아한 해결책을 제공한다. 

네비게이션 프레임워크 또는 일관된 네비게이션 접근 방식은 복잡한 앱에서 빌드, 강제 적용 또는 기존 구성 요소를 활용해야 할 요소다. 

iOS에서는 사용할 수 있는 네이티브 네비게이션 구성 요소가 하나도 없다. 몇몇 오픈 소스 프로젝트가 도움을 제공하지만, 네이게이션은 이 플랫폼에서 아직 해결되지 않은 문제다. 좋은 네비게이션을 수행할 수 있는 좋은 방법을 가지는 것이 모든 상황에서 어려울 수 있다. iOS의 Swift 네비게이션에 대한 글에서 결론을 내렸다. 

안드로이드의 경우 조금 더 앞서있다. `Jetpack Navigation Architecture Component`는 네비게이션을 위한 우선적으로 선택되는 라이브러리가 되어가고 있다. 일부 엣지 케이스를 지원하지 않는 부분을 제외하면 잘 작동한다. `Jetpack`은 2018년에 출시되었고, 자체적으로 `Activities`와 `Fragments`위에 솔루션을 빌드하는 앱은 종종 자체 스택을 유지할 것인지 이동할 것인지 결정해야 한다. `Jetpack`이 없어도 안드로이드는 `Up`및 `Back` 키에 대한 가이드라인과 백 스택을 가지고 있는 든 네비게이션 접근 방식에 더 의견이 확고하다.

모바일과 태블릿 간의 네비게이션 차이는 흥미로운 특수 사례다. 앱이 큰 화면과 양식을 가지고 있다면, 모바일 기기에서는 여러 단계나 화면이 있을 수 있고, 태블릿 버전은 하나의 단일 화면을 사용할 수 있다. 이러한 시나리오는 iOS에서 더 자주 발생할 수 있으며, 핸드폰과 태블릿 크기가 명확하게 정의되어 있다. 이 시나리오를 지원하는 것은 어렵지 않지만, 여러 계획에 따라야만 가능하다.

---

#### 14. Application State & Event-Driven Changes

모바일 앱에서 UI의 변화를 주도하는 것은 어떤것들이 있을까? 사용자가 어떤 부분을 '탭'하는 것일 수도 있고, 백엔드에서 데이터가 도착하는 것일 수도 있으며, 또는 타이머 함수가 될 수도 있다. 대부분의 변화는 `이벤트`에 의해 주도된다. 

앱의 복잡성이 증가함에 따라 가능한 상태의 수도 증가하게 된다. 어떤 상태 변경은 다른 상태 변경을 유발할 수 있다. 예를 들어, 사용자가 탭한 후에 컴포넌트가 상태를 변경하면 페이지 또는 응용 프로그램의 상태가 변경되는 것을 유발할 수 있다. 

모바일 앱은 일반적으로 웹이나 무거운 클라이언트 앱 보다 상태가 많다. '앱 잠금', '앱 전환', '백그라운드 모드' 같이 다양한 라이프사이클 이벤트를 지원해야하기 때문이다. 더불어 오프라인 모드 지원으로 인해 여러가지 다른 상태가 추가된다. 웹 앱은 라이프사이클 이벤트가 적고 거의 오프라인 모드를 광범위하게 지원하지 않는 반면, 무거운 클라이언트 앱은 라이프사이클 이벤트가 적고, 모바일과 비교할 때 연결 끊김이 훨씬 더 드물다. 

앱이 커지고 복잡해질수록, 평범하지 않은 이벤트들의 조합으로 인해 버그가 발생할 가능성이 높아진다. 일반적이지 않은 이벤트들의 문제점은 이들을 계획하거나 테스트하기 어렵게한다. 예를 들어, 컴포넌트의 상태 변경을 일으키는 백그라운드 푸시 알림이 사용자가 앱의 화면을 잠그기 직후에 도착하면, 다른 상태 변경이 발생할 수 있다. 이러한 드문 수신 이벤트 중 하나가 독립적인 컴포넌트와 팀에 의해 소비되면, 그 조합은 이례적인 버그를 발생시킨다. 

상태 변경 문제로 인한 버그 수를 낮추기 위해 상태 관리 모범 사례를 따르면 좋다. 상태를 가능한 한 변경 불가능하게 유지하고, 상태 변경을 발생하게 만드는 변경 불가능한 개체로 모델을 구성해야한다. 유효하지 않은 상태를 재생 또는 디버그할 수 있는 정보와 함께 기록하여 문제가 발생한 원인과 재현 방법에 대한 세부 정보를 얻어야 한다. 

버그 보고서 작업자 도구를 사용하는 것이 시작하기 가장 쉬운 방법이며 선택할 수 있는 도구도 많다. 여러 충돌 보고 도구도 버그 보고 컴포넌트와 함께 제공된다. 일반적으로 버그 보고 도구는 베타 사용자에게 문제점을 제출할 수 있도록 표시된다. 버그 보고서를 제출할 때 문제에 이르기까지 발생한 일련의 이벤트와 디버그에 필요한 충분한 정보를 포함해야 한다. 

대부분의 버그 보고 도구는 세션 동안 발행한로그를 첨부할 수 있도록 허용한다. 이를 위해 버그 재현이 가능하도록 충분한 로그를 발행해야 한다. 자동으로 재생, 일시 중지, 되감기 및 디버그 사용자의 세션을 수행할 수 있는 이상적인 도구로 애플리케이션 상태 문제를 디버그 해야한다. 사용자 이벤트 뿐만 아니라 들어오는 네트워크 알림의 로그를 갖고 싶을 수도 있다. 이를 스레드별로 수행할 수 있는 것이 중요하며, 이를 통해 스레드 간 문제들을 디버그 할 수 있다. 웹에서는 세션 재생 도구가 있지만 불행하게도 iOS와 AOS의 경우 커스텀 도구나 디버그 로그 또는 메모리 덤프를 사용해야 한다. 

---

#### 15. Localization

iOS와 AOS 모두 `Localization`을 구현하는 방법을 제공합니다. iOS는 번역을 위해 `Localization`을 내보내는 것(exporting localizations for translation)을 지원하지만, AOS는 리소스 문자열을 기반으로 구축합니다. 도구는 조금씩 다르지만, 컨셉은 비슷합니다. 앱을 로컬화하고, 문자열을 정의한 다음, 로컬화된 문자열을 바이너리의 별도 리소스로 제공하려고 한다. 하지만 대규모 앱과 많은 지역에서 앱 플로우와 관련된 문제가 발생한다. 

앱에서 지역화활 것인지, 백엔드에서 처리할 것인지 결정하는 것이 성장하는 앱이 처음 직면하는 도전 중 하나다. `default`를 사용하는 iOS 및 AOS 지역화 접근 방식을 사용하면 앱 내에서 로컬화하는 리소스가 바이너리와 함께 `고정(stuck)`된다. 즉, 문구를 변경하거나 오류를 업데이트할 수 없다. 공급 업체 솔루션 또는 백엔드에서 로컬화 문자열을 제공하면 이 문제가 더 유연해지고, 두 플랫폼에서 동일한 로컬화를 수행할 필요가 없다.

모바일 앱에서 얼마나 똑똑해야 하고 어떤 문자열이 여기에 저장되는지와 관련하여 논의할 내용이 더 많다. 백엔드 중심의 로컬화가 많을수록 좋다. 백엔드 중심의 로컬화는 클라이언트의 로직을 낮추고 모바일에서 로컬화를 위한 리소스 수를 줄인다. 일반적으로 iOS 및 AOS 앱 워크플로우에서 백엔드에 더 많은 로컬화를 `위임(delegate)`해야 하지만 장기적으로 유지 관리가 더 쉬워진다. 

많은 지역을 지원할 때는 모든 로컬화 번역이 앱 스토어에 출시하기 전에 완료되어야 한다. 이를 수행하기 위해 서드 파티 서비스 또는 내부 팀을 사용할 수 있다. 빌드 프로세스를 가정하면, 모든 새 리소스가 로컬화된 후에만 진행되도록 허용해야 한다. 

iOS와 AOS 앱이 동일한 또는 적어도 유사한 언어를 사용하는 것이 중요하다. 일관된 언어는 브랜드에 있어서 뿐 아니라 고객 지원이 사용자가 보고한 문제를 처리하는 데도 도움이 된다. 동일한 `Localization`도구를 사용하지 않거나 iOS 및 AOS 팀이 긴밀하게 협력하지 않는 한 이 일관성을 보장하는 것은 어렵다. 동일한 디자이너와 PM이 두 앱을 모두 감독하는 것도 도움이 된다. 동일한 ID 또는 키를 사용하는 것은 중복을 줄이는 좋은 방법이며, 이는 규칙에 동의하는 iOS 및 AOS 팀을 통해 수해되어야 한다. 

`Localization`시 커스텀 폰트는 자구 간과되는 영역이다. 큰 기업의 경우 커스텀 폰트를 사용하는 것이 흔한 일이다. 그러나 이러한 폰트는 항상 앱이 지원하는 언어 세트를 전부 지원하지 않는다. 지원하지 않는 언어와 문자를 확인하는 것이 충분히 어렵다. 이러한 문제는 폰트를 사용하여 사용자가 생성한 콘텐츠를 표시할 때 더욱 심각해진다. 사용 사례와 엣지 케이스를 파악한 후 더 자주 지원이 추가되어야 하거나 지원되지 않는 지역에 대해 다른 글꼴을 사용해야 한다. 글꼴 및 언어의 일관성 있는 크로스 플랫폼 매핑을 관리하는 것이 한층 더 어렵다. 특히 각 글꼴이 지원하는 언어를 기준으로 한다. 커스텀 폰트를 사용하면 바이너리에 포함해야 하며 앱 크기에 영향을 준다. 

특정 지역에서 iOS와 AOS에서의 통화(currency) 포맷이 다른 경우 다국어, 다중 플랫폼 앱이 통화와 관련된 문제를 경험하는 것도 공통적이다. 웹에서도 이러한 문제가 있으며, 인도의 '루피'가 좋은 예다. 특히 통화 유형을 사용하여 값을 추가하거나 뺄 때 문제가 된다. 가능한 해결책은 백엔드에서 모든 통화 데이터를 지역화 시켜 형식화하고 클라이언트가 수학 연산 또는 통화 문자열 형식화를 행하지 않게 하는 것이다. 

날짜 및 시간 서식도 비슷한 문제가 발생한다. 다른 국가와 지역에서 날짜와 시간을 다양한 방식으로 표시할 것이다. 앱은 이를 고려해야 한다. 

오른쪽에서 왼쪽 언어(Right to Left) 지원은 종종 번역을 넘어선 작업이다. 이러한 RTL 언어에 대한 UI를 설계할 때 문자열 외에도미러링 작업이 필요하다. 미러링 레이아웃은 일반적인 접근 방식이지만, 이로 인해 원어민 사람들이 경험하는 문제와 대화에 대한 이해가 부족할 수 있다. 이러한 상황에서는 UI및 UX 디자이너와 긴밀하게 협력하여 최적의 경험을 제공하는 것이 중요하다. 최근에는 대부분의 라이브러리 및 플랫폼의 프레임워크에서 RTL 지원을 개선했지만, 예외 처리가 필요할 수도 있다. 

디자인을 개선하기 위해 언어 별로 합의하거나 사용자 정의 하드 코딩 UI원소를 제거해야 할 수 있다. 이는 개발자가 사용자 지정 RTL 레이아웃을 작성하는 경우의 예외를 줄이고, 자동 RTL 레이아웃 규칙에 따라 조정하는 도구를 제공한다. 

다중 언어 및 지역 사용자에게는 앱에서 공간 요소를 잘 관리하는 것이 중요하다. 예를 들어 텍스트는 지역에 따라 다르게 길이가 변할 수 있으며, 이로 인해 UI내에서 적절한 공간을 만들어 주지 못한다면 내용이 잘리거나 겹치게 된다. 이런 경우 레이아웃을 강력하게 테스트하고 유연한 사용성과 뛰어난 현지화 경험을 보장하기 위해 디자이너와 개발자 사이의 긴밀한 협력이 필요하다. 

특정 지역은 항상 추가적인 주의를 기울여야 한다. 예를 들면 일본어와 독일어는 더 많은 확인이 필요한데, 이는 두 언어 모두 영어보다 더 길고 상세하기 때문이다. 또한 이런 경우, 레이아웃, 패딩 줄바꿈이 여전히 잘 작동하는지 확인하고 싶을 것이다. 

`Localization`을 테스트 하는 것은 쉽지 않다. 이상적인 경우, 사용자는 `Localization`가 적용된 후 앱의 모든 플로우를 거치게 된다. 사실 이런 일이 거의 일어나지 않으며, 이를 실현하는 것은 너무 많은 비용이 들기 때문이다 대부분의 대기업은 다양한 지역 설정으로 앱을 사용하는 베타 테스터들이 눈에 띄는 불일치를 보고하도록 의존하고 있다. 

이러한 변경 사항을 검증하기 위한 워크플로우를 정의해야 할 수도 있다. 앱 내에서 `Localization`된 문자열이 변경될 때 어떤 일이 발생해야 할까? 이 변경 사항을 수동으로 검사하는 작업이 트리거 되어야 할까? 아니면 해당 화면의 개발자에게 알림을 보내야 할까? 또 다른 변경 사항이 없더라도 릴리스 매니저가 새 버전의 앱을 출시해야 할까? 이런 것들은 작은 문제처럼 보일 수 있지만 그렇지 않다. 특히 번역 작업을 수행하는 사람들이 코드를 작성하는 개발자와 별개로 작업할 때는 더울 그렇다. 추가되는 것 뿐만 아니라 `Localization`을 업데이트하고 테스트하는 워크플로우를 정의할 사람이 필요하다. 

`Snapshot Test`는 과소평가된 테스팅 도구다. 스탭샷 테스트를 사용하면 모든 지역이나 심지어 유사 `Localization`으로 화면에 대한 스냅샷을 빠르고 쉽게 생성할 수 있다. 그런 다음 개발자는 레이아웃 문제를 더 빨리 발견하고 문제를 나타내는 참조 이미지를 갖게 된다. 엔지니어들을 돕는 것 뿐만 아니라 스냅샷 테스트 스크린샷을 번역 작업을 수행하는 사람들과 공유하여 번역된 텍스트가 어떻게 나타날지에 대한 추가적인 컨텍스트를 제공할 수 있다. 

`Pseudo-Localization`은 로컬라이제이션 작업을 거치지 않고도 해당 동작이 작동하는지 테스트하는 좋은 방법이다. 이는 모든 로컬라이즈 가능한 요소를 개발자가 읽을 수 있는 유사 언어로 대체하는 것을 의미한다. 이러한 `유사 언어`는 다른 언어의 어려운 요소인 특수 문자나 긴 문자열과 같은 요소를 대부분 포함하고 있다. 

마지막으로 내부 정책에 기반해서 기업의 브랜드 용어 같은 경우는 `Localization`을 적용하지 않는 경우도 있다. 


---

#### 16. Modular Architecture & Dependency Injection

앱이 점점 커짐에 따라 앱의 일부를 재사용 가능한 `컴포넌트`나 `모듈`로 구성하는 것이 합리적일 때가 많다. 대규모 기업에서는 여러 앱이나 여러 모바일 팀을 보유하게 되는 경우, 다른 팀이 소유한 코드를 재사용하는 것은 당연한 일이다. 예를 들어 모바일 플랫폼 팀은 네트워킹과 공유 아키텍처 컴포넌트를 소유할 수 있다. 금융 팀은 결제 컴포넌트를 구축하고 소유하며, 지도 팀은 지도 관련된 모든 부분을 소유할 수 있다. 앱 내의 컴포넌트와 모듈은 종종 회사 팀의 구조에 매핑되어 `Conway 법칙`으로 알려진 방법을 반영한다. 

여러 모듈이 있는 경우, 모듈은 모듈 수준과 클래스 수준에서 의존성을 정의할 수 있는 방법이 필요하다. 이 개념은 `의존성 주입`으로 `의존성 역전`의 한 형태이다. 이것은 앱 개발에서 간단하지만 과소평가되는 개념으로, 백엔드와 웹 프로젝트에서는 더 일반적으로 사용되는 개념이다. 

의존성 주입의 주요 과제는 프레임워크를 사용하지 않는 경우 의존성을 수정하거나 업데이트하는데 필요한 작업량이다. 프레임워크를 사용하지 않더라도 이 작업의 시간 소비적인 특성은 더 명확한 추상화와 좋은 테스트 가능성을 위한 교환권이다. 

의존성 주입은 코드베이스 전체에서 일관된 견고한 코드를 유지하는 강력한 도구다. 의존성 주입을 사용하면 여러 의존성을 갖는 클래스를 인스턴스화할 때 mock 의존성 클래스르르 전달해 유닛 테스트를 수행할 수 있다. 크고 모듈화된 앱은 이 개념을 적용한 방식 또는 다른 방식으로 도입하는 경향이 있다. 

수동 의존성 주입(Manual DI)는 모든 인터페이스를 생성한 다음 모든 의존성을 하드코딩하는 방식으로, 의존성의 수가 적을 떄는 잘 작동한다. 하지만 컴포넌트 수와 의존성 수가 증가함에 따라 의존성의 유지 관리와 업데이트가 어려워진다. 순환을 일으키는 의존성과 같은 것을 찾는 것도 까다로워지며, 의존성 주입 프레임워크를 사용하는 것이 더 의미있게 된다. 

안드로이드는 컴파일 타임에 의존성을 분석하는 의존성 주입 프레임워크인 `Dagger2`를 보유하고 있다. Google은 최근 `Dagger` 위에 구축된 프레임워크인 `Hilt`를 소개했으며, 코틀린과 함께 더욱 인기를 얻고 있다. 

iOS에서는 비슷한 프레임워크가 없지만, 우버에서 비슷한 개념을 기반으로 `Needle`을 구축하고, 사용하며 오픈 소스화했다. 의존성 주입이 없으면 수백 명의 엔지니어가 동일한 코드베이스에서 작업할 때 코드의 확장이 어려줄 것이다. `Needle`을 사용해 모든 클래스 의존성을 명시적으로 정의하고 유닛 테스트를 쉽게 수행하며, 컴포넌트를 팀 간에 재사용할 수 있다. 

---

#### 17. Automated Testing
큰 규모의 앱에서는 자동화 테스트 수행을 필요로 한다. '큰 앱' 이란, 복잡한 코드베이스 또는 여러 사람이 기여하는 규모를 의미한다. 

`Unit Test`: 유닛 테스트는 가장 간단한 자동화 테스트로, 독립된 구성 요소인 `유닛`을 테스트한다. 이는 보통 클래스 내의 메서드의 동작이나 클래스의 특정 동작을 테스트하는 것을 의미하며, 작성하고 이해하기 쉽고 실행 속도가 빠르다. </br> 
`Integration Test`: 유닛 테스트보다 복잡한 단계로, 여러 유닛 간의 상호 작용을 테스트한다. 이러한 테스트는 유닛 테스트보다 복잡하며, 실행 시간이 더 오래 걸릴 수 있다. `Mock 객체`를 사용할 수도 있고, 그렇지 않을 수도 있다. </br>
`Snapshot Test`: UI요소나 페이지의 레이아웃을 참조 이미지와 비교하는 테스트다. 이는 코드 변경이 예상치 못한 UI 변경을 초래하지 않는지를 쉽게 확인할 수 있다.</br>
`UI Test`: UI를 실행하고 특정한 방식으로 동작하는지를 테스트한다. 입력은 UI 자동화를 통해 이뤄지며, UI는 가정을 검증하기 위해 검사된다. UI 테스트는 보통 작성하기 가장 복잡하며, 시간이 모래 걸린다. UI 테스트는 종종 백엔드 엔드포인트를 Mock 객체로 대체한다.</br>

`Unit Test`는 지속 가능한 엔지니어링을 위한 기본 도구로, 여러 엔지니어로 구성된 팀과 복잡한 모바일 앱을 가지고 있을 때 중요한 역할을 한다. 비즈니스 로직을 테스트하고, 코드 리뷰를 하기에, 버그 발생이 줄어든다. 또한 의미 있는 리팩토링을 진행하고 기술적 부채를 정리하는 데 안전망 역할을 한다. 기존에 테스트가 없는 앱을 상속받고, 앱의 부분들이 테스트 가능한 방식으로 구축되지 않았다면, 새로운 코드 작성 시 천천히 유닛 테스트를 추가하고 통합테스트를 추가하는 것 외에는 다른 선택지가 없을 수 있다. 

`Integration Test`는 유닛 테스트보다 복잡하다. 두 개 이상의 클래스, 모듈 또는 다른 유닛이 어떻게 함께 작동하는지를 테스트한다. `Integration Test`의 가장 일반적인 경우는 라이브러리 통합이 예상대로 작동하는지 확인하는 것이다. 특히 다른 앱 부분에서 재사용할 라이브러리와 모듈에 대해 통합 테스트는 특히 유용하다. `Integration Test`는 라이브러리/모듈의 공개 API를 실행하고 해당 구성 요소가 예상대로 작동하는지 확인한다. `Integration Test`의 특별한 경우는 앱의 일부분을 UI 테스트하는 것인데, 이는 `End to End` 테스트는 아니다. `Integration Test`는 유닛 테스트보다 작성과 유지보수 비용이 더 많이 든다. 그러나 더 큰 범위를 테스트하므로 더 가치있을 수 있다. 

`Snapshot Test`는 자동화된 테스트의 다음 단계이다. 페이지가 생성되고 스크린샷이 찍힌 다음 저장된 이미지와 비교한다. 일반적으로 사용하는 데이터의 경우 `Mock 데이터`로 대체된다. `Snapshot Test`는 구축 비용이 적고 엔지니어의 빠른 반복 주기를 돕는 데 도움이 될 수 있다. UI를 변경한 후 테스트를 다시 실행하고 변경된 UI와 비교 결과를 확인할 수 있다. 

`UI Test`는 대규모로 수행될 떄 제한적일 수 있다. 애플은 기본적으로 UI 테스팅을 제공하며 이는 수동으로 녹화한 것을 재생하는 과정이다. 이 도구는 몇 가지 테스트 케이스에 대해서는 잘 작동한다. 하지만 더 큰 규모의 앱에서는 더 견고한 솔루션을 엔지니어링하고 로봇이나 페이지 객체와 같은 접근 방식을 사용해야 한다. 

테스트용으로 `Mock 데이터`를 사용하는 것은 자동화된 테스트의 또 다른 복잡성이다. 모의 데이터를 사용하는 것에는 여러가지 장접이 있을 수 있다. 
- 속도: 데이터를 Mocking해서 사용하면 실시간으로 가져오는 것보다 테스트가 더 빠르게 실행된다. 실시간 데이터는 네트워크를 통해 가져와야 한다.
- 엣지 케이스: 극단적인 시나리오를 나타내는 모의 데이터를 설정하는 것이 실시간 데이터로 이를 수행하는 것보다 훨씬 쉽다.
- 신뢰성: 실시간 데이터를 사용할 때 테스트는 네트워크 또는 백엔드 문제로 실패할 수 있다. 이것은 어떤 경우에는 좋을 수 있지만, 문제를 발생시킬 수 있다.
- 빈도: 테스트가 빠를수록 모든 변경 사항마다 테스트를 실행하는 것이 의미가 있다. 변경된 코드를 실행하는 로컬 테스트를 실행한다. 이렇게 하면 개발자에게 거의 즉각적인 피드백이 가능하다.

`Moking`된 데이터를 사용하는 것은 테스트 케이스 수가 늘어날수록 다뤄야 할 몇 가지 문제가 있다. 
- 실시간 데이터와 모의 데이터가 동기화되지 않을 수 있다. 테스트가 통과하더라도 앱이 실패한다면 테스트의 가치는 크지 않다. 실시간 데이터가 변경될 때 이를 감지하고 모의 데이터를 업데이트하는 방법을 찾아야 한다.
- 테스트 데이터를 관리해야 한다. 테스트 데이터를 이해하고 수정하는데 어렵지 않으며, 새로운 데이터와 테스트 케이스를 추가하는 것을 너무 어렵지 않게 만드는 관리법을 선택해야 한다.
- 복잡한 UI 테스트에서는 데이터가 동적으로 변경되는 시나리오를 작성하고 싶을 수 있다. 이 경우 데이터를 어떻게 관리할지에 대ㅐ해 고민해야 한다.

[별도 내용 추가]
- `Mock`: 실제 객체의 행동을 모방해 테스트 중에 호출되는 메서드를 감시하고 기대한 대로 동작하도록 만든 객체. 해당 메서드가 얼마나 잘 실행되었는지가 중요하다.
- `Spy`: 실제 객체와 매우 유사하게 동작하는 객체로 메서드 호출 및 반환 값을 감시하고 기록하는 역할. 상태와 행위를 동시에 테스트한다.
- `Stub`: 실제 객체의 메서드를 대체하는 객체로 특정 메서드를 호출할 때 미리 정의된 값을 반환하도록 설정. Mock이 행위 검증이었다면, Stub은 상태 검증이다.
- `SUT`: System Under Test의 약자로 테스트 하고자 하는 코드를 의미

---

#### 18. Manual Testing
작은 앱의 경우, 수동 테스트를 진행하는 것이 실용적인 방법이지만, 앱이 커지게되면, 지루한 테스트가 반복된다. 대규모로 확장될 때 매주 릴리스되는 앱에서 많은 엔지니어들이 작업하는 상황에서는 이러한 접근법이 실패할 수 있다. 대규모에서의 목표는 항상 수동 테스트에 대한 의존도를 최소한으로 유지하면서 배포 가능하도록 유지하는 것이다. 수동 테스트가 선택적으로 이뤄지더라도 큰 오버헤드가 아니거나 이러한 테스트를 허용할 충분한 자동화된 테스트가 마련되어 있지 않은 경우에도 몇 가지 도전 과제가 있다. 

수동 테스트에서 빈번하게 발생하는 문제 중 하나는 릴리스 직전에 버그가 발생한다는 것이다. 이는 새로운 리그레이션과 함께 릴리스하는 대안보다는 괜찮지만, 개발자들이 버그를 빨리 수정해 릴리스 지연을 피해야 하는 압박감을 느끼에 할 수 있다. 버그의 근본 원인을 찾는 것은 종종 어려울 수 있다. 문제가 발생한 코드가 병합된지, 일주일 이상이 지난 경우가 많다. 만약 이 순간의 버그 보고 문제가 영향을 미친다면 피드백을 받는 시간을 줄이는 것을 고려해야 한다. 수동 테스트 프로세스가 있는 경우, 테스트만 수행하는 데만 시간을 할당하는 것 뿐만 아니라 고수준 버그를 수정하는 데도 충분한 시간이 확보되어 있는지 확인해야 한다. 이를 위해서는 수동 테스트를 일찍 수행하고 수정에 충분한 여유 시간을 남기거나 유연하게 대처하고 리그레이션이 발견된 경우 릴리스 일정을 미루는 방법을 선택할 수 있다. 

하지만, QR, AR 등 물리적인 상호 작용의 경우 수동 검증이 필요하다.
