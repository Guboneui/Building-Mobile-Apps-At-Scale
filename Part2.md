### PART2: Challenges Due To APP Complexity

앱의 크기가 커짐에 따라, 상황이 흥비로워진다. 계속해서 새로운 기능을 추가하면서 기존 기능도 조정해야한다. 즉, 화면을 플로우 차트에 출력한다면, 몇 개의 화면이 벽 전체를 덮을 정도로 복잡해진다. 

대규모이고 복잡한 앱을 다룰 때 추가적인 도전에 직면할 수 있다. 점점 복잡해지는 네비게이션 패턴을 어떻게 다루어야 할까? 결정적이지 않은 이벤트 조합은 어떻게 다뤄야 할까? 여러 언어로 번역하는 것은 어떻게 해야 하며, 자동화된 테스트와 수동 테스트를 어떻게 확장해야 할까?

---

#### 13. Navigation Architecture Within Large Apps

모바일 앱 내에서 `네비게이션(Navigation)`은 딥링크와 마찬가지로 과소평가된 문제 영역이다. 앱이 작을 때는 그에 대해 크게 주의하지 않지만, 앱이 성장함에 따라 화면과 전환의 수가 증가하면서 탐색 구조가 길들여야 할 야수(beast)가 되었음을 깨닫게 된다. 

iOS와 안드로이드 모두 기본적인 네비게이션 개념을 제공하지만, 실제 네비게이션 아키텍처를 정의하는 작업은 개발자에게 맡겨진다. 결과적으로 네비게이션을 위해 흔히 휠을 다시 발명하게 된다(we tend to reinvent the wheel on navigation). 이는 대부분 iOS나 안드로이드가 단순한 앱을 넘어서 잘 확장되지 않는 네비게이션 접근 방법을 제공하지 않기 때문에 필요한 일이다. 

앱 상태를 잘 분리한 명확한 앱 네비게이션 전략을 가지는 것은 어느 정도 크기의 앱에 대해서도 중요하다. 화면과 구성 요소 사이에서 어떤 탐색이 일어나는 걸까?. 탭과 제스처 사이에서 어떤 애니메이션이 트리거되며, 네이게이션은 앱 상태와 독립적일까?

많은 팀은 코드를 작성하는 도중 어려움을 겪게 되면, 일관되지 않은 네비게이션 솔루션을 구축해, 사용자가 예상치 못한 상태에 빠졌을 때 버그가 발생하는 것을 발견할 수 있다. 

일관되지 않은 네입게이션은, '팝업', '토스트', '모달', 또는 화면을 일관성 없이 사용하는 앱과 같이 눈에 띌 수 있다. 서로 다른 화면 사이에서 다른 애니메이션이 사용되는 것을 의미할 수도 있다. 이로 인해 앱의 네비게이션 작동에 대한 코드 중복이 많아진다. 

비동기 네비게이션 작동은 몇몇 개발자가 미리 처리하는 것을 고려하지 않는 일반적인 문제다. 여기서 말하는 비동기 네비게이션은 네비게이션 동작이 계속되기 전에 무언가가 끝나야 하는 경우를 의미한다. 앱에 로그인하거나 양식을 제출하는 것이 이에 해당한다. 사용자가 이 단계에서 네비게이션을 시도하면 어떻게 될까? 이러한 시나이로를 계획하고 테스트 하지 않으면 앱이 이상한 상태에 빠질 수 있다. `RIBs`를 사용하면 워크 플로우가 이 문제에 우아한 해결책을 제공한다. 

네비게이션 프레임워크 또는 일관된 네비게이션 접근 방식은 복잡한 앱에서 빌드, 강제 적용 또는 기존 구성 요소를 활용해야 할 요소다. 

iOS에서는 사용할 수 있는 네이티브 네비게이션 구성 요소가 하나도 없다. 몇몇 오픈 소스 프로젝트가 도움을 제공하지만, 네이게이션은 이 플랫폼에서 아직 해결되지 않은 문제다. 좋은 네비게이션을 수행할 수 있는 좋은 방법을 가지는 것이 모든 상황에서 어려울 수 있다. iOS의 Swift 네비게이션에 대한 글에서 결론을 내렸다. 

안드로이드의 경우 조금 더 앞서있다. `Jetpack Navigation Architecture Component`는 네비게이션을 위한 우선적으로 선택되는 라이브러리가 되어가고 있다. 일부 엣지 케이스를 지원하지 않는 부분을 제외하면 잘 작동한다. `Jetpack`은 2018년에 출시되었고, 자체적으로 `Activities`와 `Fragments`위에 솔루션을 빌드하는 앱은 종종 자체 스택을 유지할 것인지 이동할 것인지 결정해야 한다. `Jetpack`이 없어도 안드로이드는 `Up`및 `Back` 키에 대한 가이드라인과 백 스택을 가지고 있는 든 네비게이션 접근 방식에 더 의견이 확고하다.

모바일과 태블릿 간의 네비게이션 차이는 흥미로운 특수 사례다. 앱이 큰 화면과 양식을 가지고 있다면, 모바일 기기에서는 여러 단계나 화면이 있을 수 있고, 태블릿 버전은 하나의 단일 화면을 사용할 수 있다. 이러한 시나리오는 iOS에서 더 자주 발생할 수 있으며, 핸드폰과 태블릿 크기가 명확하게 정의되어 있다. 이 시나리오를 지원하는 것은 어렵지 않지만, 여러 계획에 따라야만 가능하다.

---

#### 13. Navigation Architecture Within Large Apps

모바일 앱에서 UI의 변화를 주도하는 것은 어떤것들이 있을까? 사용자가 어떤 부분을 '탭'하는 것일 수도 있고, 백엔드에서 데이터가 도착하는 것일 수도 있으며, 또는 타이머 함수가 될 수도 있다. 대부분의 변화는 `이벤트`에 의해 주도된다. 

앱의 복잡성이 증가함에 따라 가능한 상태의 수도 증가하게 된다. 어떤 상태 변경은 다른 상태 변경을 유발할 수 있다. 예를 들어, 사용자가 탭한 후에 컴포넌트가 상태를 변경하면 페이지 또는 응용 프로그램의 상태가 변경되는 것을 유발할 수 있다. 

모바일 앱은 일반적으로 웹이나 무거운 클라이언트 앱 보다 상태가 많다. '앱 잠금', '앱 전환', '백그라운드 모드' 같이 다양한 라이프사이클 이벤트를 지원해야하기 때문이다. 더불어 오프라인 모드 지원으로 인해 여러가지 다른 상태가 추가된다. 웹 앱은 라이프사이클 이벤트가 적고 거의 오프라인 모드를 광범위하게 지원하지 않는 반면, 무거운 클라이언트 앱은 라이프사이클 이벤트가 적고, 모바일과 비교할 때 연결 끊김이 훨씬 더 드물다. 

앱이 커지고 복잡해질수록, 평범하지 않은 이벤트들의 조합으로 인해 버그가 발생할 가능성이 높아진다. 일반적이지 않은 이벤트들의 문제점은 이들을 계획하거나 테스트하기 어렵게한다. 예를 들어, 컴포넌트의 상태 변경을 일으키는 백그라운드 푸시 알림이 사용자가 앱의 화면을 잠그기 직후에 도착하면, 다른 상태 변경이 발생할 수 있다. 이러한 드문 수신 이벤트 중 하나가 독립적인 컴포넌트와 팀에 의해 소비되면, 그 조합은 이례적인 버그를 발생시킨다. 

상태 변경 문제로 인한 버그 수를 낮추기 위해 상태 관리 모범 사례를 따르면 좋다. 상태를 가능한 한 변경 불가능하게 유지하고, 상태 변경을 발생하게 만드는 변경 불가능한 개체로 모델을 구성해야한다. 유효하지 않은 상태를 재생 또는 디버그할 수 있는 정보와 함께 기록하여 문제가 발생한 원인과 재현 방법에 대한 세부 정보를 얻어야 한다. 

버그 보고서 작업자 도구를 사용하는 것이 시작하기 가장 쉬운 방법이며 선택할 수 있는 도구도 많다. 여러 충돌 보고 도구도 버그 보고 컴포넌트와 함께 제공된다. 일반적으로 버그 보고 도구는 베타 사용자에게 문제점을 제출할 수 있도록 표시된다. 버그 보고서를 제출할 때 문제에 이르기까지 발생한 일련의 이벤트와 디버그에 필요한 충분한 정보를 포함해야 한다. 

대부분의 버그 보고 도구는 세션 동안 발행한로그를 첨부할 수 있도록 허용한다. 이를 위해 버그 재현이 가능하도록 충분한 로그를 발행해야 한다. 자동으로 재생, 일시 중지, 되감기 및 디버그 사용자의 세션을 수행할 수 있는 이상적인 도구로 애플리케이션 상태 문제를 디버그 해야한다. 사용자 이벤트 뿐만 아니라 들어오는 네트워크 알림의 로그를 갖고 싶을 수도 있다. 이를 스레드별로 수행할 수 있는 것이 중요하며, 이를 통해 스레드 간 문제들을 디버그 할 수 있다. 웹에서는 세션 재생 도구가 있지만 불행하게도 iOS와 AOS의 경우 커스텀 도구나 디버그 로그 또는 메모리 덤프를 사용해야 한다. 
